[{"title":"关于Docker镜像定制和前端多项目Gitlab CI/CD的整理","url":"/tech/docker-usage.html","content":"\n\n## 一、缘起\n\n由一次内部系统小改引发的旧系统迁移以及两个系统的整合部署。目标是一个容器内跑新旧两套系统，并用一个域名承载！\n\n\n## 二、故事开始\n\n### 1、镜像升级（定制镜像）\n\n发现新系统在Node版本方面，有不一致的地方，比如`编译环境是node-v12.x`，而实际容器的`运行版本则是node-v10.x`，这还没算部分项目有依赖安装的场景...对于Web项目本身可能影响不大（已知node-sass对版本有依赖，使用Sass时需要注意），但是如果跑Node服务就会有影响（js引擎在不同版本之间往往会有差异），更何况不同的版本之间默认NPM也不一致，也会造成安装的依赖存在略微差异！\n\n除了Node版本，nginx也一样。理论上讲，最新的稳定版本应该也会比老舅的性能更好，特别是版本差的太多的！\n\n![](/img/2020/16299487948150.jpg)\n\n本来是想在之前的镜像上直接升级，后来觉得OS是不是也能折腾一下（主要是我米SRE提供的标准镜像都太老舅），于是就去Docker官方找了标准镜像\n\n![](/img/2020/16299488888874.jpg)\n\n#### 系统版本说明\n\n- alpine：Alpine Linux操作系统。占用空间最少（工具和基础软件包没有），但出现问题比较难以调试。**一般不要选择这个类型**；\n- buster：基于Debian Linux发行的版本，比较新且支持全面。**一般使用这个类型即可（大多镜像默认就以此为基础）**；\n- stretch：另一个基础Debian Linux发行的版本，相对于Buster系统比较老舅，建议不要使用（除非硬件不支持新系统）；\n\n> 最终基础镜像选择为：Debian Linux 10.10(buster)。在搜索上选择了最新的nginx版本，即：1.21.1。如果本地已经安装好了Docker环境，则直接黑窗口执行：docker pull nginx:1.21.1\n\n**基础镜像下载到本地之后，就可以定制环境了。一般有两个姿势：**\n\n##### 纯手工打造：\n\n1. 启动容器，安装基础工具（curl/procps/vim等）和项目运行环境（node/nrm/yarn/cnpm/pm2等）。考虑node未来升级的可扩展性，我们可以通过nvm来安装node。需要注意的是**通过nvm安装后，一定要把环境变量导出**。否则容器启动后会因找不到类似npm命令导入安装依赖或在线打包失败.....\n2. 系统参数调优，比如nginx默认的一些配置，是否开启GZIP等；\n3. 通过容器ID提交新的镜像并push到镜像仓库，具体参考以下步骤：\n\n```shell\n# 1. 从官方拉取基础镜像\ndocker pull nginx:1.21.1\n \n# 2. 查看本地镜像编号/名称\ndocker images\n \n# 3. 启动镜像容器（映射宿主机的一个目录到容器内，主要方便文件交换）\ndocker run -itv /Users/tangkunyin/docker:/home ${镜像ID} /bin/bash\n \n# 4. 提交容器到镜像\n## 查看容器id\ndocker container ls -as\n \n## 提交容器并打标\ndocker commit 9cae32ff7102 registry.cn-guangzhou.aliyuncs.com/thomax/nginx-node:1.21.1-14.16.0\n \n# 登录镜像仓库并push\n## 名字注意换成你的\ndocker login registry.cn-guangzhou.aliyuncs.com --username=xxx\n \n## 确认无误后推送镜像\ndocker push registry.cn-guangzhou.aliyuncs.com/thomax/nginx-node:1.21.1-14.16.0\n```\n\n##### 通过Dockerfile自动打造：\n\n```shell\nFROM nginx:stable\n \nLABEL maintainer=\"Thomas Tang <thomas@tangkunyin.com>\"\nLABEL description=\"Based on the nginx:stable, node installed by nvm and nrm yarn all installed\"\n \n \nENV NVM_VERSION 0.38.0\nENV NODE_VERSION 14.16.0\nENV NVM_DIR /usr/local/nvm\n \n# Replace shell with bash first so we can source files\nRUN rm /bin/sh && ln -s /bin/bash /bin/sh && \\\napt-get update && \\\napt-get install -y curl vim procps net-tools iputils-ping openssh-client openssh-server && \\\nrm -rf /var/lib/apt/lists/* && \\\nmkdir -p /usr/local/nvm && \\\ncurl -o- https://raw.githubusercontent.com/nvm-sh/nvm/v${NVM_VERSION}/install.sh | bash && \\\n. $NVM_DIR/nvm.sh && \\\nnvm install ${NODE_VERSION} && \\\nnvm alias default ${NODE_VERSION} && \\\nnvm use ${NODE_VERSION} && \\\nnpm install -g nrm yarn && \\\nnrm use cnpm && \\\nnvm cache clear\n \nENV NODE_PATH $NVM_DIR/versions/node/v$NODE_VERSION/lib/node_modules\nENV PATH $NVM_DIR/versions/node/v$NODE_VERSION/bin:$PATH\n```\n\n`在文件同级目录下执行编译：docker build -t registry.cn-guangzhou.aliyuncs.com/thomax/nginx-node:1.21.1-14.16.0 .`\n\n以上构建成功后，参考手动部分再push到镜像仓库，即可完成镜像的定制！\n\n### 2、子项目依赖\n\n要实现一个容器里跑多个系统，项目代码最好就集中到一个主仓库，一来简化开发流程，二来也方便Gitlab打包的镜像包含所有的dist。所以 Git Submodule就用到了，不过特别需要注意的是**子项目路径依赖最好用相对路径，而不是直接https/ssh**。对于项目都在同一个gitlab甚至是一个群组内，这个方式非常适合。如果是分布在不同git服务器上，则需要使用其他姿势了，具体自行谷歌容器之间配置SSH信任。\n\n另外 Gitlab的Runner也需要额外配置一下，因为构建时它默认并不会去拉submodule仓库。我们只**需要在 gitlab-ci.yml 中 variables 里添加一行：GIT_SUBMODULE_STRATEGY: recursive **\n\n`git submodule`里的内容参考如下：\n\n```\n[submodule \"platform-v1\"]\n    path = platform-v1\n    url = ../platform-v1.git\n    branch = \"master\"\n```\n\n### 3、缓存策略的使用\n\n通过Gitlab进行CI/CD中最浪费时间的地方就是安装依赖和在线打包，其中前者往往是很多前端同学的噩梦，为了尽可能提升流水线效率。我们就需要用到合理的缓存策略来加速。默认的策略是：push-pull，在默认方式下，每个Job开始执行前都会去检测并下载缓存文件，任务结束后又会上传一遍文件。但并不是每个Job都需要这样：\n\n- 依赖安装：把首次安装好的node_modules缓存到FDS上，如果package文件不变，则后续流程就不用在进行依赖安装。对于这个阶段来说我们不需要检测FDS是否有缓存，要做的只是变更后push新的缓存包。**因此这个阶段改成：push**\n- 编译打包：用安装阶段已经缓存的node_modules直接编译项目，完后不需要再上传文件。**因此这个阶段改：pull**\n\n这样，FDS下载和上传的时间就被节省掉（node_modules包特别大时效果明显）。再有，缓存如果是被多个Job所共享，需要注意使用一致的名称和一致的path，否则Job执行时会相互影响\n\n这里建议用**分支+自定义标识**为缓存包做命名，比如这种：`key: \"${CI_COMMIT_REF_NAME}-dependenciesCache\"`\n\n其中，`CI_COMMIT_REF_NAME` 是gitlab预定义变量值，参见：https://docs.gitlab.com/ee/ci/variables/predefined_variables.html\n\n这种命名的好处是生产环境依赖和测试环境依赖可以有效区分开，避免可能的影响！\n\n###  4、入口文件优化\n\n每一个使用Docker来部署的应用的项目在其根目录都有一个Dockerfile文件，这个文件用来定义容器的运行时环境以及启动时应该执行的脚本任务。但对于复杂场景来说，Dockerfile中的 ENTRYPOINT或CMD指令就不太好描述了，特别是当需要判断环境执行不同任务时。此时一个shell文件就会解决所有难题，例如：\n\n```shell\n#!/bin/bash\n \nset -e\n \nmkdir -p /home/work/log\n \n# Starting nginx server\nnginx\n \n# Starting node server. Note that staging won't run old-server\nif [[ $runEnvArg == 'prd' ]]; then\n    cd /home/work/app/xxx-platform/platform-v1/server && npm run online >> /home/work/log/xxx-old.log &\n    echo \"old server is running................................\"\nfi\n \ncd /home/work/app/xxx-platform/server && npm run $runEnvArg >> /home/work/log/xxx-new.log\n \nexec \"$@\"\n```\n\n原来的`ENTRYPOINT`指令改为：`ENTRYPOINT [\"./docker-entrypoint.sh\"]`\n\n### 5、容器启动失败\n\ndocker容器不同于虚拟机，我们可以简单粗暴的理解为宿主机内的一个进程。因此从这个角度来说，容器需要有一个前台任务“卡”着才能正常运行。否则“进程”启动后就会自动退出。所以重点来了，如果你的容器**启动后无故自动退出且没有其他报错信息，请第一时间检查是否有前台命令**.....对于前端来说这个命令不是nginx就是node。注意我再说一遍，不管哪个命令一定是前台执行，即：卡着黑窗口不退出的那种.....\n\n另外值得一提的是容器本地调试，如果发布平台上操作哪哪都不对，又不想浪费Gitlab流水线时间，那完全可以把已构建成功的镜像（你要部署的那条）直接下载到本地调试！\n\n### 6、子系统访问路径的问题\n\n这方面，需要注意两个问题，一是项目本身的`publicPath` ，二是nginx的`root/alias`指令。比如我开始提到的，我要一个域名跑新旧两个项目：\n\n- 新：https://xxx.blog.tangkunyin.com\n- 旧：https://xxx.blog.tangkunyin.com/v1\n\n此时，旧项目在打包dist时就需要配置**publishPath为v1**，而nginx的配置就取决于旧项目包绝对路径，**事实上使用alias指令，自由度会更高**\n\n###  7、CI文件优化不完全指北\n\n总的来说就是用gitlab手动维护多套基础模板，业务使用时，直接`include`基础模板并把需要的变量传递进去，而不是在每个项目的`gitlab-ci.yml`文件写一大堆冗余的配置。这样做的好处不言而喻，除了简单便捷，也在宏观层面尽可能统一了研发/运维的标准。尤其是对于新手同学，统一姿势会节省的大量宝贵的时间。\n\n\n## 三、阅读资料\n\n- https://wgjak47.me/tech/gitlab-ci_submodules/\n- https://zhuanlan.zhihu.com/p/106971627\n\n","tags":["码常规","生产力"],"categories":["科技"]},{"title":"零基础学琴（起步篇）","url":"/huma/piano-learning-part1.html","content":"\n## 学前准备\n\n### 基础设施\n\n- [61/88键电子琴一台](https://item.jd.com/1746198905.html)\n- [头戴式耳机一副](https://item.jd.com/100000998920.html)（主要是防止扰民）\n- 平板/大屏手机一台（看曲谱或者智能音乐App跟弹）\n\n### 目标与步骤\n\n> 从最容易入手的电钢琴开始，以即兴伴奏为核心学习\n\n- 时间\n    + 练琴时间：单次练习不要超过30分钟，之后休息5到10分钟再继续练\n    + 时间分配：清晨练习以及其他兴奋状态下\n- 步骤\n    + **有计划地安排练习内容**：从简单到复杂曲谱集合，每首曲子要清楚连的是什么\n    + **对于每首曲子的难点**：暂时给予这些乐段以优先的地位，即抓住难点进行训练\n- 方法\n    + 循序渐进：从最简单的伴奏方式开始练起。最简单的伴奏方式是左手弹和弦根音，即和弦中几个音里最低的音。右手弹整个和弦。左手大的，可以弹两个八度的两个根音\n    + 边弹边唱：手上无歌，心中有歌，才能跟上\n    + 先分后合：先练右手，再练左右，两手再合。不要两个手一起练，否则事倍功半，因为没有单独练习，不熟练，难以配合\n\n\n#### 慢速练习\n放慢速度是解决各类技术难点的首选方法，也是最有效的方法。慢练的目的，是让头脑清醒地向肌肉发出演奏某个乐句的正确指令。并检查肌肉的反应和动作是否正确\n\n#### 分手练习\n分手练习可以使注意力集中于较单一的要求上，降低练习的难度，同时还能够对旋律、乐句、声部、伴奏的认识更加清晰。更加明确弹奏时两手各自的任务。最后使双手的合奏达到准确无误\n\n#### 变化练习\n将练习的内容可以进行改变节奏、改变触键、改变奏法、改变力度、改变常规指法练习等来训练，变化的目的是增强技术难度。训练大脑对手指的指挥和控制能力，达到解决技术难点的目的\n\n#### 倾听练习\n将自己的音乐听觉思维充分调动起来，不急不躁不激动，冷静地倾听自己弹奏的声音，根据音乐形象可将音准、节奏、和弦、强弱、快慢、弹奏动作等方面做总体把握。及时地调整，对自身的弹奏做一个全面的鉴别\n\n\n> 练习时我们不可能把每一首都弹到尽善尽美，但要尽量把所学作品都有所浏览。不必弹得多么熟练，但一定要有所顾及。这样慢慢地，你就会发现原来自己是可以完成、做到的， 日积月累。练习的质量和数量都会有所提高。那么练琴的内容就会越来越宽泛了。\n\n### 干货教程\n\n#### 必看\n\n- 《数字灵感钢琴课程——精华十二课》\n- 《蓝调小生司琴即兴伴奏一点通》\n- 《教你快速识简谱》\n\n#### 补充\n\n- 《教会键盘速成教材（基础）之快速入门基本的指法（右手和左手基本指法）》\n- 《琴之缘电子琴和弦指法》\n- 《钢琴弹唱的秘密》\n\n\n### 避坑指南\n\n- 避免长时间机械地反复练习一首整曲，不仅浪费了宝贵的时间，反而使头脑处于迟钝状态\n\n","tags":["音乐","钢琴"],"categories":["人文"]},{"title":"Codereview姿势探索","url":"/tech/codereview-explore.html","content":"\n### Code Review的意义\n\ncode review是现代软件开发非常有意义的一种技术管理方法，其价值不止在于代码的准入和找bug，也是所有人技术交流和成长的一种手段，总结CR的意义，不限于：\n\n- 找出可能的坑\n- 帮助新人成长\n- 互相督促代码质量\n- 互相学习设计理念及编码思路\n\n理想情况下所有代码合并都必须进行code review，并且必须CC整个组，让你的每一个合并都更认真地对待\n\n### phabricator\n\n诞生于Facebook内部，是一套基于Web的软件开发协作工具，包括代码审查工具Differential，资源库浏览器Diffusion，变更监测工具Herald，Bug跟踪工具Maniphest和维基工具Phriction。Phabricator可与Git、Mercurial和Subversion集成使用。\n\n其本身是PHP开源程序：[https://github.com/phacility/phabricator](https://github.com/phacility/phabricator)\n\n#### 系统配置\n\nPHP环境请自行google，这里记录nginx配置\n\n```nginx\nserver {\n    \n    set $content \"~/dev-lib/phabricator/webroot\";\n\n    listen 80;\n\n    server_name phabricator.tangkunyin.com;\n\n    root  $content;\n   \n    location / {\n        index  index.php index.html index.htm;\n        rewrite ^/(.*)$ /index.php?__path__=/$1 last;\n    }\n\n    location ~ \\.php$ {\n        fastcgi_pass                127.0.0.1:9000;\n        fastcgi_index               index.php;\n        fastcgi_intercept_errors    on;\n        include /usr/local/etc/nginx/fastcgi.conf;\n    }    \n\n}\n```\n\n运行后，会提示通过命令设置**Mysql**信息，一般情况下直接设置密码即可\n\n![](/img/2020/15984343118360.jpg)\n\n接着，会让你更新数据库信息，同样按提示操作即可\n\n![](/img/2020/15984345189850.jpg)\n![](/img/2020/15984344260057.jpg)\n\n如此**phabricator**就算安装完成了，接下来根据引导配置一下系统各项参数。以下这些看情况配置就好\n\n![](/img/2020/15984364325138.jpg)\n\n\n#### 项目配置\n\n先下载并配置环境变量：https://github.com/phacility/arcanist\n再设置帐号信任：\n\n```\narc set-config default http://phabricator.tangkunyin.com/\narc install-certificate http://phabricator.tangkunyin.com/\n```\n\n执行后会提示到网站上找到对应的token，找到后粘贴输入。注意提示的网址应该是：[http://phabricator.tangkunyin.com/conduit/login/](http://phabricator.tangkunyin.com/conduit/login/)，如果不是重新登录以加载新的配置\n\n最后在项目中创建**.arcconfig**文件并配置基础项，完整配置请自提自：`arc get-config --verbose`\n\n```\n{\n  \"phabricator.uri\" : \"https://phabricator.d.xiaomi.net/\",\n  \"history.immutable\": false\n}\n```\n\n\n\n##### review步骤：\n\n1、git commit你的修改\n2、开始review\n\n```\narc diff commit_id --create\n\n或修改\n\narc diff commit_id --update D12306  （这儿的D12306是上一次review时的revisionId）\n```\n\n3、填写review信息\n![](/img/2020/15984431302261.jpg)\n\n\n4、现在你会收到邮件，也可以在网站上看到你的review，请大家评审吧\n\n5、merge仍然要在gitlab中完成，merge消息中要带上phabricator的review地址，证明这次merge是review过的，收到了accept的review才进行合并\n\n\n**需要注意的是我这里并没有提到邮件发送配置，实际过程是要配置的，不然上边的邮件肯定发不出去**\n\n具体参考这篇文章：https://cloud.tencent.com/developer/article/1609447\n\n平台操作资料：[Phabricator Code Review操作手册](https://jaycelau.github.io/2018/08/27/Phabricator-code-review-pre-push-%E6%93%8D%E4%BD%9C%E6%89%8B%E5%86%8C/)\n\n\n","tags":["码常规","生产力"],"categories":["科技"]},{"title":"版本管理论","url":"/tech/about-git.html","content":"\n## 背景\n\n随着同一业务线研发人力增多，混乱往往就逐渐成为了必不可免的问题。此时如果没有一套科学的流程规范，成员「个性」将会导致项目维护成本越来越高\n\n本文主要从`分支`和`日志`两个方面来谈谈**git**在项目版本管理中的策略\n\n## 分支管理策略\n\n说到分支管理，就不得不提工作流。目前业内广泛使用的工作流有三种：**Git flow**、**Github flow**、**Gitlab flow**\n\n在写这篇文章之前，我用过的也只有`Git flow`一种，我原以为其一招鲜就可吃遍天，结果发现这事还没那么简单。对于[这三种工作流的介绍](http://www.ruanyifeng.com/blog/2015/12/git-workflow.html)，阮一峰老师的博客里写的很清楚，科普请自提之。这里主要说使用策略\n\n> 阶段性版本发布项目（Git flow）\n\n对于目标是一段时间以后产出一个新版本的项目，`Git flow`是合适的。特别是对于小团队单线开发，不会有多需求同时开发的情况。使用Git-flow可以最大程度保证项目安全、有节奏的完成发布和管理。因此Git-flow适合有节奏按版本发布的项目，团队人员在4人以下\n\n在这种流程下，需要同时维护两个长期分支：master、develop。比较合适的场景有：\n\n- 开源类库\n- 客户端项目（如iOS App）\n\n\n> 持续发布项目（Github flow 与 Gitlab flow）\n\n对于发版不固定，甚至代码一有变动，就部署一次的项目。`Github flow`是合适的。因为这种流程足够简单，就一个长期分支**master**维护。比较合适的场景有：\n\n- Web或者动态化业务（RN、Weex）\n- 后端接口服务\n\n\n![](/img/2020/15973293762112.jpg)\n\n上图是`Github flow`的一个单线使用流程。而在互联网公司中往往为了最大化产研资源利用率，当前功能刚提测，下一轮评审可能就来了，即一波赶一波。目前在我的团队，工作流以这个思想为前提稍加了改造，如图：\n\n![](/img/2020/15976778223233.jpg)\n\n关于CI部署方面，统一走Tag事件，避免不小心合并到主分支导致提前发布\n\n### 另外\n\n`gitlab flow`倡导的**上游优先**策略不仅有能适应不同开发环境的弹性，也有单一分支管理的简单和便利。不过个人感觉没有前两种来的爽快...维护成本也不低。所以具体用哪种，还是综合下来看场景\n\n### 合并小插曲\n\n#### 快速合并（Fast Forward）\n\n![](/img/2020/15972141617652.jpg)\n\n![](/img/2020/15972143912031.jpg)\n\n#### 常规合并（--no-ff）\n\n![](/img/2020/15972145096579.jpg)\n![](/img/2020/15972146124778.jpg)\n\n从**sourceTree**图可以看到，如果执行快速合并，开发者根本不会看到被合并的分支，就像在当前分支直接commit一样\n\n正常合并如果没有合并冲突，都会进行快速合并。但是对于大多数功能驱动式项目开发来说，要尽量避免快速合并，毕竟有些时候还是要追溯log，不仅对于代码分析特别有用，另外保证整个项目提交链的完整性也很有必要\n\n## 日志管理策略\n\n### 起因\n\n某次项目质量管理时发现了如下图这样的提交...一个修bug的操作，commit却密集的提交了7次之多\n\n![](/img/2020/15979060369139.jpg)\n\ngit日志过于随意会有什么问题？也许你会说代码写对、项目正常跑不就完了呗，何必纠结那些细节。但如果意识到以下问题，可能你就不这么想了：\n\n- 正常运行的功能出问题，要回滚代码到某个改动前或者查哪个改动引起的问题\n- Code review，试想一些很小的改动，却多次无效提交，一个个看会不会崩溃\n- 提取迭代的记录（CHANGELOG）做某项总结，结果发现这段时间都TM干了些啥\n- 破窗效应，分支污染将导致恶性循环，对往后的管理和维护是在埋雷\n\n### 策略\n\n此模块包含以下两个部分\n\n- commit lint：用于在提交前检查commit message是否符合规范\n- commit tool：帮助我们简便生成符合规范的commit message\n\n具体用法教程太多，比如这个帖子：https://juejin.im/post/6844903710112350221\n\n### 逼格\n\n![](/img/2020/15979963651090.jpg)\n\n如果想在日志里做点骚操作，可以考虑**emoji**。要实现这个你需要关注两个库：`gitmoji`、`emojify`\n\n库安装好以后，在项目根目录执行：`gitmoji -i`，用来加git钩子，使得commit时可以弹出交互式moji对话框。另外配合zsh增加别名，让git log色彩斑斓\n\n```\nalias gl=\"git log --color | emojify | less -r\"\n```\n\n## 参考资料\n\n- [Git 工作流程](http://www.ruanyifeng.com/blog/2015/12/git-workflow.html)\n- [Git-Rebase](http://jartto.wang/2018/12/11/git-rebase/)\n- [commitlint](https://github.com/conventional-changelog/commitlint)\n- [gitmoji](https://github.com/carloscuesta/gitmoji-cli)\n- [emojify](https://github.com/mrowa44/emojify)\n- [![Commitizen friendly](https://img.shields.io/badge/commitizen-friendly-brightgreen.svg)](http://commitizen.github.io/cz-cli/)\n\n","tags":["码常规","生产力"],"categories":["科技"]},{"title":"Niz折腾之旅","url":"/tech/niz-keybord.html","content":"\n### 背景\n\n最近NIZ的**command**键非常不好使，并且**shift**也不动不动失灵。起初以为用的时间太久里面掉灰影响灵敏度了，于是将其大卸八块，仔细做了保洁，装上再试时，发现还是那样....于是萌发了固件升级的念头\n\n![IMG_0024](/img/2020/IMG_0024.jpg)\n\n### 操作\n\n根据[官方的视频](https://www.bilibili.com/video/av44071224/)，找到了对应的「刷机包」，如下：\n\n![](/img/2020/15951685744116.jpg)\n\n![](/img/2020/15951682959499.jpg)\n\n一顿操作之后，发现问题解决了。欣喜万分...遂写下此日记！\n\n### 后记\n\n对于专业软件「操盘手」来说，有一款称手的利器再好不过，以前用过**ikbc**的红轴，也用过**HHKB TypeS Pro2**，发现都不爽。主要是前者因为机械键盘钢板的问题导致键盘很重，另外ikbc的红轴偏软，敲击感受不爽；后者虽然重量和感觉非常好，但是无奈有线限制，另外**HHKB**的出线方式个人感觉挺SB的....这一点要赞一下**ikbc**的两端走线\n\n后来各种调研后选择了静电容键盘里的国产货，也就是本文的主角：**NIZ**，中文名：宁之，又称普拉姆。其实很早之前见朋友用过此货，颜值非常高，当时记忆算是深刻\n\n我入手的是`micro82双模白色 45g`，体验至今感觉很超值，算得上是国货精品。当然不可否认的是，键盘稳定性还是有待提高。不过其团队还算负责，有专门的QQ群且一直提供升级包供专业人士折腾。如果你恰好看到这个文章，也想换个键盘，你可以考虑一下这个。可以说比动辄上千的机械键盘乐趣更大\n\n传送门：https://item.jd.com/37696679702.html\n\n","tags":["生产力","黑科技"],"categories":["科技"]},{"title":"vscode中调试node.ts","url":"/tech/debug-nodets-in-vscode.html","content":"\n### 背景\n\n纯前端程序用Chrome大法调试自然不易翻车，另外打log也能输出对象、数组等复杂数据类型。但这一切换到nodejs环境就没那么爽了，黑窗口里输出复杂数据类型不仅看的眼花又缭乱，而且跟踪断点非常蛋疼，所以这就需要借助IDE能力去断点调试。\n\n谷歌给出的文章时间上都比较老舅，所以写了这个笔录。本文采用vscode + nest搭配，系统环境在macOS下\n\n> vscode版本是：1.46.1，开始之前最好配置一些偏好设置\n\n![](/img/2020/15934149425950.jpg)\n\n![](/img/2020/15934151685607.jpg)\n\n\n\n\n### 调试步骤\n\n确认启动调试的命令是否ok，主要看start命令是否有**--debug**参数\n\n![](/img/2020/15934007141581.jpg)\n\n点「甲壳虫」后，出现如下界面，接着点**Node.js Debug Terminal**\n\n![](/img/2020/15934008571189.jpg)\n\n不出意外，nodejs就可以调试了（得在js文件上打断点，如果是ts则找build后的js文件）......\n\n**此时，如果在ts源文件中直接打断点，可以看到的是，没有反映....**，于是我们来折腾一下这块\n\n#### 配置TypeScript调试\n\n##### 姿势一\n\n`tsconfig.json`中开启**sourceMap**，即：`\"sourceMap\": true,`。一行见效\n\n![](/img/2020/15934142161875.jpg)\n\n\n##### 姿势二\n\n`ts-node`大法\n\n详见资料：[使用ts-node和vsc来调试TypeScript](https://segmentfault.com/a/1190000010605261)\n\n\n### 延伸阅读\n\n- [使用 VS Code 调试 Node.js 的超简单方法](https://juejin.im/post/5cce9b976fb9a0322415aba4)\n- [deno vs ts-node](https://mlog.club/article/5002614)\n\n","tags":["码常规","typescript","后端"],"categories":["科技"]},{"title":"对工作的思考","url":"/huma/thinking-about-work.html","content":"\n### 关于\n\n> 特别提示：本文说的工作泛指工程方向，这里特指软件研发。没有对其他行业做调研，也不太了解，所以不要全信，也不要不信！\n\n#### 种类（按工作内容）\n\n- 日常工作：按部就班的作业\n- 应急工作：自己负责的模块出问题后要做的作业（跟日常工作质量密切相关）\n- 研发工作：前两种作业完成后。独立或共同研讨的对策、规划、调研等，不一定是编码\n\n以上是当年刚入职小米时，某总监在一次晨会上提到的。作为已经工作好几年的人，当时听到这个话还是挺激动，所以我就深刻的记下了。一直一来，工作上我都参考这个规则来展开，尽可能避免一直处于日常工作当中的状态。\n\n在软件开发领域，我们常常听到两种岗位：开发工程师和研发工程师，其实想想区别也倒简单，根据以上看哪个做的更多罢了。\n\n\n### 思考\n\n算了一下，到今天为止已经满载满荷的工作8个年头了。其中前些年主要还是以写代码为主，近两年开始专职带团队做事。当然工作内容发生了很大变化，所以我觉得有必要有个思考。这篇文章只是一个开始.....\n\n几乎每个技术人也都会面临这个问题，即到某个时间开始带人做事，随着团队规模越来越大，自己写码的时间越来越少，然后出现两个明显的问题：\n\n- 没更多时间和精力专心撸码，担心技不如人（下次找工作尴尬）\n- 不适应新经理角色，也很难一下做好。随之而来的挫败感大大降低了工作的幸福程度（不如编码实在）\n\n难道对于技术和管理，就没法二者兼得了！？其实不然，关于这个话题的讨论网上有很多。这里不再赘述......\n\n之前在某档管理课程学习的结论直接分享出来：\n\n1. 专业线解决专业问题，管理线解决业务目标达成。后续并非一定存在高低，更多看个人发展。\n2. 用目标来带动能力的提升（对于管理岗的患得患失）\n\n\n#### 时间问题\n\n按每天有效时间6小时（2 + 4）算，一周只有30小时，编码如果20%，那就是整整一天.....对于管理8+的一线Leader来说，最好不要超过这个阀值，长期如此大概率会害人害己......\n\n另外几个重要的关键词：**惜时**、**主动**、**深度思考**\n\n![我全要](/img/2020/%E6%88%91%E5%85%A8%E8%A6%81.png)\n\n\n\n\n\n","tags":["碎碎念"],"categories":["人文"]},{"title":"记一次Mysql再安装的坑史","url":"/tech/reinstall-mysql.html","content":"\n### 背景\n\n多年前帮朋友写过一个PHP的项目用过Mysql，后来硬盘空间不够了，所以卸载了。当时只是卸载没有清理干净，毕竟默认情况下卸载Mysql是不会自动删除**db**文件夹的，于是今天又有相关需求再次安装时，翻车了...\n\n```\n(HY000): Can't connect to local MySQL server through socket '/tmp/mysql.sock' (38)\n```\n\n\n#### 解决姿势\n\n起初以为**mysql.sock**这个文件没有，另外`brew services restart mysql`再怎么启动都也不明显报错....于是[各种操作配置](https://segmentfault.com/q/1010000000094608)，一顿搞还是连不上。于是怒看Log...\n\n![](/img/2020/15913469404177.jpg)\n\n上图是`/usr/local/var/mysql/KunyinTang.local.err`中发现的，看上去跟我之前那个版本不兼容导致安装后服务没启动.....\n\n于是，一顿操作卸载并删除了所有相关的老的、新的mysql文件....整理的操作如下：\n\n```bash\ncd /usr/local/etc\nrm -rf my.cnf my.cnf.default\n\n\n# 旧的数据文件如果有用要记得保存一份！\nsudo rm -rf /usr/local/mysql\nsudo rm -rf /usr/local/var/mysql\n\nsudo rm -rf /Library/StartupItems/MySQLCOM\nsudo rm -rf /Library/PreferencePanes/My*\nsudo rm -rf ~/Library/PreferencePanes/My*\nsudo rm -rf /Library/Receipts/mysql*\nsudo rm -rf /Library/Receipts/MySQL*\nsudo rm -rf /private/var/db/receipts/mysql\n```\n\n删完之后再用**brew**装一遍，问题解决了....\n\n```bash\nbrew install mysql\n\n# 看看是不是启动了\nlsof -i :3306\n```\n\n![](/img/2020/15913475899004.jpg)\n\n\n再然后就可以愉快的玩了.....\n\n![](/img/2020/15913478197693.jpg)\n\n\n\n","tags":["码常规","麦克"],"categories":["科技"]},{"title":"微前端框架实践","url":"/tech/practice-in-microfrontends.html","content":"\n## 说明\n\n此次实践对比相对知名的框架：single-spa，icestark，qiankun\n\n其中在[微前端](https://blog.tangkunyin.com/tech/micro-frontends-1588056860.html)这篇文章中我们可以看到，icestark，qiankun，Magix三个都是阿里旗下的产物，分别由baba和mama实现。下边将对各个框架逐一踩坑\n\n> 开始之前，我先从[stateofjs](https://2019.stateofjs.com/front-end-frameworks/)找了排前三的前端框架作为子项目\n\n### single-spa\n\n- 官网：https://single-spa.js.org/docs/getting-started-overview\n- 类型：\n    + application / parcel：同属UI层，区别是前者为特定路由渲染微前端UI，后者不受路由限制（通用组件UI）\n    + utility module (styleguide, api cache, etc)：逻辑层，暴露（通用）共享逻辑（helpers...）\n    + root config：微应用入口配置（至少得有一个）。包括一个被所有single-spa应用共享的html文件和一个注册子应用的js文件，当然二者是可以合并成一个文件的，即可以在一个html里完成所有配置。\n\n#### 新项目接入\n\n> 整个新建过程使用**create-single-spa**命令生成脚手架代码，请`npm install -g create-single-spa`先\n\n##### 1. 创建俩不同框架的application\n\n```bash\nmkdir single-spa-demo && cd single-spa-demo && mkdir apps && cd apps\n\ncreate-single-spa react-app\ncreate-single-spa vue-app\n```\n![](/img/2020/15893705237392.jpg)\n\n##### 2. 创建root-config\n\n![](/img/2020/15898796344044.jpg)\n\n注意**Organization**这里不要为空，否则会有[问题](https://github.com/single-spa/create-single-spa/issues/102)\n\n##### 3. 启动微服务并尝试接入子应用\n\n###### 启动基座\n\n> 如果直接启动，你会发现有这个问题：[Unable to resolve bare specifier 'single-spa'](https://github.com/single-spa/create-single-spa/issues/122)。然后你需要从**[cdnjs](https://cdnjs.com/)**手动添加一个库。后来从官方了解到**>=1.8.0**之后就没有这个问题了，实测是这样。所以如果遇到这个问题，请更新cli版本\n\n![](/img/2020/15899468623500.jpg)\n\n实际上在`index.ejs`中，我们可以看到还有一个`systemjs-importmap`是被注释起来的。我们打开注释并加入依赖的核心库\n\n```html\n<script type=\"systemjs-importmap\" src=\"/importmap.json\"></script>\n```\n\n```json\n{\n  \"imports\": {\n    \"single-spa\": \"https://cdnjs.cloudflare.com/ajax/libs/single-spa/5.5.1/umd/single-spa.min.js\",\n    \"react\": \"https://cdnjs.cloudflare.com/ajax/libs/react/16.13.1/umd/react.production.min.js\",\n    \"react-dom\": \"https://cdnjs.cloudflare.com/ajax/libs/react-dom/16.13.1/umd/react-dom.production.min.js\",\n    \"vue\": \"https://cdnjs.cloudflare.com/ajax/libs/vue/2.6.11/vue.min.js\"\n  }\n}\n```\n\n###### 接入子应用\n\n`react`和`vue`按照上面的命令一顿操作下来基本没啥问题，但`svelte`命令里没有集成，所以我们需要人肉集成\n\n```bash\nnpx degit sveltejs/template svelte-app\n```\n\n然后参考：https://single-spa.js.org/docs/ecosystem-svelte\n\n这样一顿操作之后，你又会发现`Svelte`挂掉了\n\n![](/img/2020/15900327650573.jpg)\n\n紧接着，你需要把代码稍加改造\n\n```javascript\nconst svelteLifecycles = singleSpaSvelte({\n  component: function() {\n    return SvelteApp;\n  },\n  domElementGetter: () => document.getElementById(\"svelte-app\"),\n  props: {}\n});\n```\n\n此时，三大框架均已成功融合到`single-spa`微应用了\n\n```javascript\nregisterApplication({\n  name: \"svelte-app\",\n  app: () => System.import(\"@thomas/svelte-app\"),\n  activeWhen: \"/\",\n});\n\nregisterApplication({\n  name: \"react-app\",\n  app: () => System.import(\"@thomas/react-app\"),\n  activeWhen: \"/react\",\n});\n\nregisterApplication({\n  name: \"vue-app\",\n  app: () => System.import(\"@thomas/vue-app\"),\n  activeWhen: \"/vue\",\n});\n```\n\n```html\n<script type=\"systemjs-importmap\">\n    {\n      \"imports\": {\n        \"@thomas/root-config\": \"//localhost:9000/thomas-root-config.js\",\n        \"@thomas/react-app\": \"//localhost:9001/thomas-react-app.js\",\n        \"@thomas/vue-app\": \"//localhost:9002/js/app.js\",\n        \"@thomas/svelte-app\": \"//localhost:9003/build/bundle.js\"\n      }\n    }\n  </script>\n```\n\n![](/img/2020/15900344790504.jpg)\n\n### icestark\n\n- 官网：https://ice.work/docs/icestark/about\n- 核心：\n    + 框架应用：一个系统只有一个框架应用，框架应用负责系统整体的 Layout 以及子应用的管理与注册（由于目前的API设计参考了React Router，同时为保证开发体验，框架应用跟React做了耦合，所以框架应用必须基于React）\n    + 子应用：通常是一个单页面应用，可能包含一个或多个页面，子应用负责自身相关的几个页面代码。\n\n#### 新项目接入\n\n相比**single-spa**，icestark的接入姿势简单许多，官方文档又是中文的，建议直接搬命令操作。\n\n整体感觉封装的比较彻底，不需要过多配置。新项目入手还是很方便的，唯一会有的问题就是官方基座模板使用了**icejs**，无形之中又增加了一种学习成本。\n\n#### 改造旧项目\n\n为了探究**icestark**的能力，这里我用改造旧项目的方式整合一个微前端应用。首先还是用官方的姿势创建一个框架应用\n\n![](/img/2020/15904965198873.jpg)\n\n##### 子项目改造\n\n首先添加依赖`yarn add @ice/stark-app`，然后根据官方文档进行[已有项目改造子应用](https://ice.work/docs/icestark/guide/child-app)。一切顺利的话，如下图就完成了icestark的整合！\n\n![](/img/2020/15905896307429.jpg)\n\n### qiankun\n\n- 官网：https://qiankun.umijs.org/zh\n\n从官方介绍来看，乾坤是基于**single-spa**的微前端实现库。因此一些概念和实现可能需要往上再看一遍\n\n#### 新项目接入\n\n> **qiankun**不像`single-spa`官方那样提供一个**cli**命令去生成主应用和子应用，也不像`icestark`那样主应用必须是React。因此对于`qiankun`大法，主应用可以自由选择，比如用`create-react-app`或`vue-cli`。此处用`@vue/cli 4.3.1`创建主应用\n\n另外官方例子中，有二者的实现，有需要可以参考一下：[examples](https://github.com/umijs/qiankun/blob/master/examples/main/index.js\n)。主应用创建完成后，基本上按照[官方的文档](https://qiankun.umijs.org/zh/guide/getting-started)一顿操作即可集成\n\nqiankun官方文档相当简介，以至于稍不注意就看完了，我竟然还会有一种意犹未尽的感觉...以为上了个假官网！\n\n\n## 总结\n\n几乎遵循这两年流行的思想，即：「去中心化」。分治而又在某个统一规则下玩，除了**single-spa**，后边的**icestark**和**qiankun**都分别支持**html entry**，即某种成都上用一样的方式解决了样式隔离等微前端核心难题\n\n从接入的友好性和研发成本来看，阿里的库无疑是比较好的选择，而`icestark`和React绑的比较重，从官方文档可以看到他们还有很多事情要处理，所以综合下来`qiankun`算是目前最好的微前端框架了。\n\n之后有时间再剖一篇原理实现，敬请期待！\n\n## 资料\n\n\n- [助力 20+ 阿里内部平台级系统，面向大型应用的开源微前端解决方案 icestark](https://developer.aliyun.com/article/757143)\n- [这可能是你见过最完善的微前端解决方案！](https://www.infoq.cn/article/o6GxRD9iHQOplKICiDDU)\n- [Vue + Qiankun 快速实现前端微服务](https://iamtaoxin.com/2020/03/01/vue-qiankun/)\n- [基于 qiankun 的微前端实践](https://juejin.im/post/5e85a679e51d4546f27fe2d0)\n\n\n\n","tags":["前端","javascript"],"categories":["科技"]},{"title":"年轻人的第一次「保养」","url":"/huma/car-first-maintenance.html","content":"\n### 标题解释\n\n> 本文说的保养是指汽车保养，至于为啥说是年轻人的第一次，其实事后想想蛮有代表性...\n\n### 首保的那些事情\n\n自从去年末提了爱车成为非专业老司机后，惊喜一直不断。一晃就从6km飙到了5836km（当然不全是我自己行驶的距离），首保将至，内心也惶恐万分，毕竟印象里各种说法都暗示4S店保养神坑......\n\n带着这种纠结的心情，5号去了4s店，接待挺热情，一顿操作后手续就办下来了。因为住处停车非常艰难，本来想车子给他们我先忙我的去，等我哪天想用车了再过来提，不料这个羊毛没有薅成，所以就不得不去休息室耐心的等待了\n\n#### 首保内容\n\n- 机油机滤\n- 空调出风口清灰\n- 胎压及其他方面例行检查\n- 专业洗车一次（免费）\n- 燃油添加剂（**自费218**）\n\n客户经理基本上是照着保养手册执行，其中有个燃油添加剂惹得我不太爽。他的解释是换机油有个回流过程，机油会回流到汽油油箱里导致一些问题，加这个的目的是为了清理发动机...而且还是必须要弄的！\n\n![](/img/2020/15890125179962.jpg)\n\n![](/img/2020/15890125401414.jpg)\n\n其实我大概知道这个玩意是啥用途，毕竟从去年买车开始就一直关注某档说车的音频节目。包括后边跟朋友确认了下，同款车型人家保养就没提这个事情，算是一个可有可无的操作。到我这里就成了强制销售......\n\n可以看到下边这张图，我从某宝搜到的商品，一样的东西一样规格，价格只有一半不到。可以肯定的是，4s店拿货价格比某宝的价格还要低，所以这其他的价格差去哪儿了？既然免工时、机油、机虑这些保养常用操作，那多的这些会不会就是休息室里喝咖啡的钱！？\n\n![](/img/2020/15890127849776.jpg)\n\n后边想了想，其实当时如果坚持不要这个应该也可以正常保养（或者换个说法家里有一模一样的东西），毕竟这个不是保养时必须加进去的东西，自己后续等燃油耗尽加进去或者不加其实没啥影响，实属可选项目！另外客户经理给的理由也不太能经得起推敲.....\n\n正是由于担心会伤害发动机或因不选择服务影响整体质保，所以选择相信，继而被套路。人家也是抓住客人这点心理，所以还是自己太年轻.....\n\n\n### 汽油之间也有学问\n\n汽油这个事情，没车之前没咋关注。没想到这里面水也不浅...中石油、石化、壳牌甚至乙醇汽油这些常用油，最近看了些资料，说说结论：\n\n#### 1. 组织模式\n\n国营：中石油、中石化、中海油\n合资：壳牌、道达尔、BP\n民营：以莆田系为主，比如中国国际能源、亚孚石化、中国油联、中图、中胜等\n\n#### 2. 地理分布\n\n**北方：**中石油、延长壳牌（我老家陕西会多一些）、乙醇汽油（东北三省、河南、安徽5省等）\n**南方：**中石化\n\n#### 3. 优劣情况（个人结论）\n\n延长壳牌 > 中石油 > 中石化 > 乙醇汽油\n\n> 注意：论环保程度，那得把乙醇汽油排第一位了。但是正常情况来看，油价贵、动力差、油耗高这三项可能不太会有人选它。当然某些观点会认为中石化的优于中石油（既定事实是炼油技术里中石化确实NB，而本身不负责原油开采），不过都是国标油三者里取距离最近岂不更好！\n\n#### 4. 资料\n\n[乙醇汽油](https://zhuanlan.zhihu.com/p/82997535)\n[乙醇汽油2020年将全面推广，有些话总要有人告诉您](https://zhuanlan.zhihu.com/p/96762477)\n[2019年中国加油站品牌力分析](https://zhuanlan.zhihu.com/p/91902349)\n\n\n\n","tags":["旅行","养车"],"categories":["人文"]},{"title":"微前端","url":"/tech/micro-frontends.html","content":"\n### 背景\n\n大前端时代下，大型单体架构模型面临三大难题：扩展性差、团队维护成本大（耦合度与复杂性）、编译部署效率低下\n\n#### 概念\n\n> 微前端是一种架构风格，其中众多独立交付的前端应用组合成一个大型整体\n\n类似于微服务的架构，它将微服务的理念应用于浏览器端，即将 Web 应用由单一的单体应用转变为多个小型前端应用聚合为一的应用。各个前端应用还可以独立运行、独立开发、独立部署。\n\n##### 与业务组件/widget区别\n\n![](/img/2020/15889903896063.jpg)\n \n##### 部署方式\n \n ![](/img/2020/15880677006053.jpg)\n\n##### 价值\n\n+ 工程价值\n    + 优点\n        - 独立开发和部署\n        - 大型单页应用无限扩展\n        - 不限技术栈\n        - 多团队协作 \n    + 缺点 \n        - 体验有折损（子应用异步加载不如SPA如丝般顺畅）\n        - 维护成本高（子应用拆太多，多个仓库，共用组件复用都是问题）\n        - 管理版本复杂、依赖复杂\n        - 开发体验不太友好（需要不同工程切换以及启动多个子系统）\n        - 粒度不宜太小（跟通用组件区分好）\n+ 业务价值\n    + 产品“原子化”（根据业务自由的编排组合）：扩展性、组合性、局部迭代\n    + 解决能力输出最后一公里的价值（使得别人集成你的能力变得简单）\n    + 云生态的新物种 ----- 微应用\n\n#### 现状\n\n##### 业界方案\n\n- single-spa\n- Mooa（适用于NG的微前端框架，基于single-spa）\n- Ara Framework（基于airbnb服务端渲染的微前端框架）\n- Ali\n    + baba \n        - WidgetJS（轻量级的微前端方案，不过文档不友好）\n        - icestark（自主研发，较single-spa更简单轻量级的微前端框架）\n        - qiankun（基于single-spa的框架无关的微前端框架）\n    + mama\n        - Magix（通过特有的vframe(类似iframe的思路)帮你把页面按区块化拆分）\n\n\n### 起飞资料：\n\n- [未来前端开发的新趋势 — 第四部分](https://juejin.im/post/5d23394ae51d45778f076db0)\n- [大前端时代下的微前端架构：实现增量升级、代码解耦、独立部署](https://www.infoq.cn/article/03*BeU3zQegIbIytRsX9)\n- [目标是最完善的微前端解决方案 - qiankun 2.0](https://zhuanlan.zhihu.com/p/131022025)\n- [微前端 qiankun 项目 实践 !!! 防踩坑指南](https://juejin.im/post/5ea55417e51d4546e347fda9)\n- [微前端方案 icestark 的现在与未来](https://zhuanlan.zhihu.com/p/101164985)\n- [面向大型工作台的微前端解决方案 icestark](https://zhuanlan.zhihu.com/p/88449415)\n- [年度文章集合 | 最全微前端集合](https://juejin.im/post/5e01f2bff265da33e2290c75)\n- [第十四届D2前端技术论坛视频](https://list.youku.com/albumlist/show/id_52355444?spm=a2h9p.12366999.app.SECTION~MAIN~SECTION~MAIN~5~5!2~5~5~5~5~A)\n\n","tags":["前端","javascript"],"categories":["科技"]},{"title":"无损音乐一把","url":"/huma/flac-music.html","content":"\n### 原起\n\n昨晚失眠到凌晨两点，于是开始听歌，辗转反侧时意外发现QQ音乐上王卡老用户有绿钻羊毛可薅，于是欣然薅掉。之后把之前不能听的挨个听了个遍.....\n\n第二天，登录macOS桌面版，把经常喜欢听的全部用无损格式下载了一遍，然而发现下载文件格式是被加密过的（也在情理之中......）。然后找了找解码工具，还真在万能的github找到了：https://github.com/Presburger/qmc-decoder\n\n一顿操作后，所有文件顺利解码。剩下的问题是，测试这些爱曲是不是真的FLAC\n\n#### 第一轮测试：auCDtestTaskManager\n\n> 通过率：89.05%\n\n![](/img/2020/15874437535005.jpg)\n\n\n#### 第二轮测试：Lossless Audio Checker\n\n> 通过率：100%\n\n![](/img/2020/15874489546332.jpg)\n\n\n\n##### 失败文件名称\n\n- 周杰伦-床边故事\n- 周杰伦-告白气球\n- 周杰伦-说走就走\n- 周杰伦-爱情废柴\n- 周杰伦-前世情人\n- 周杰伦-一点点\n- 周杰伦-Now You See Me\n- 周杰伦-不该\n- 周杰伦-画沙\n- 周杰伦-等你下课\n- 周杰伦-说好不哭\n- 周杰伦-不爱我就拉到\n- 周杰伦-龙卷风live\n- 林俊杰-爱要怎么说出口\n- 林俊杰-女儿情live\n- 林俊杰-输了你赢了世界又如何live\n- 张信哲-平凡之路live\n\n![](/img/2020/15874499980563.jpg)\n\n\n##### 失败文件再检测\n\n![](/img/2020/15874492263018.jpg)\n\n\n### 通过一波波操作，选出合格的无损文件\n\n![](/img/2020/15874506941901.jpg)\n\n最后，sony-1000xm3走起...\n\n","tags":["音乐"],"categories":["人文"]},{"title":"记录一下用MWeb写文章的配置姿势","url":"/tech/config-about-mweb-writing.html","content":"\n\n### 先介绍下工具本身\n\nMWeb是一款macOS下优秀的markdown写作工具，很早之前有个活动，于是在水果店买了一份，那也是第一次花钱买正版软件\n\n你还别说，真是香！\n\n后来，不知道为啥升级到3.x之后，开始重新收费了。我以为之前买断了版权，没想到这个跟windows还挺像，哈哈\n\n![](/img/2020/15864874491666.jpg)\n\n### 废话不多说\n\n看下写文章结合图片的配置吧，请注意我这里是：2.3.0 (316) 版本\n\n![](/img/2020/15864893117070.jpg)\n\n\n配置步骤如下：\n\n![](/img/2020/15864893609084.jpg)\n\n\n![](/img/2020/15864894169710.jpg)\n\n注意第二步的**media save path**这个要选**absolute**，这样当你用微信或QQ截图粘贴时，它会自动把图片保存到**media foler name**拼起来的那个文件夹里\n\n这个操作还是很方便图片管理的，最终结果图片和文章友好共存，在本地和线上都能正常预览！\n\n这个文章主要是记录下配置，方便日后换机。之前误删过MWeb App，后来找不到添加外部文件夹的地方了.....所以！\n\n\n\n\n","tags":["生产力","配置"],"categories":["科技"]},{"title":"准备桌面应用开发","url":"/tech/prepare-to-dev-desktop.html","content":"\n对这个话题，差不多两年前有一个简单的小调研：[跨端桌面应用解决方案与开发](https://blog.tangkunyin.com/tech/cross-platform-desktop-1528555686.html)\n\n没想到过了这么久，这个话题几乎还是保持原封不动的结论！\n\n### Electron姿势\n\n在这次着手准备之前，我把希望放到了**Electron**上，于是分别调研了[electron-vue](https://github.com/SimulatedGREG/electron-vue)和[electron-react](https://github.com/electron-react-boilerplate/electron-react-boilerplate)\n\n一顿脚手架把玩之后，除了后者看起来规范一些外，前者运行都报错[issues](https://github.com/SimulatedGREG/electron-vue/issues/1003)。如果你是非常钟爱react + redux + ts组合的人，那入坑就对了。基本上你要的模板代码都有，包括**prettier**这种都是给你配置好了的，工程化结构很清晰。反观vue模板，electron版本竟然在**2.0.18**......wtf，这都2020年了，查了下那还是9012年3月份的版本，这一年**Chrome**都升级N次了，注意现在已经到81.x了.......\n\n除了版本落后外，vue库更新算是比较慢了，最后一次提交是在4个月前。react版本是9天前，所以这也是为啥推荐入坑react版本的原因。当然，我比较头疼是不只是版本问题，Electron本身存在的重大缺陷之一的打包文件体积大似乎这段时间并没有啥改善.....\n\n于是我又看了下它表兄弟：**[electrino](https://github.com/pojala/electrino)**，好家伙更新倒是在29天前，不过文档写的迷一样，几乎不知道怎么开始，有个[issues](https://github.com/pojala/electrino/issues/16)比较有意思，之后随便翻了下google发现资料少的可怜，于是我也就准备弃坑了！\n\n在这之后，我把目光放到了：react-native\n\n### React-Native大法\n\n如我之前调研的结果一样，这么长时间以来这个方向几乎还是那几个库，其中**[react-native-macos](https://github.com/ptmt/react-native-macos)**也已经半年没有过提交记录了，我试着运行了下脚手架，但初始化都失败了，见[issues](https://github.com/ptmt/react-native-macos/issues/248)。然后[releases](https://github.com/ptmt/react-native-macos/releases)列表里头最近的tag是支持到RN44，拜托现在官方已经62.2了，看来作者差不多也是弃坑跑路了....\n\n不过windows下的[react-native-windows](https://github.com/microsoft/react-native-windows)在微软强有力的支持下，更新倒是挺频繁，我也相信应该是目前React-Native大法最佳的桌面端实现，不过我用的是macOS，就没再去尝试demo.....有windows条件和需求的可以看看，人家确实挺用心在搞：[getting-started](https://microsoft.github.io/react-native-windows/docs/getting-started)\n\n> 一个小插曲，我发现[RN-Win官方](https://microsoft.github.io/react-native-windows/)说支持Mac，结果文章下头却是：**Coming soon!**。翻到[ms-rn](https://github.com/microsoft/react-native)后，我又发现一个[MR](https://github.com/microsoft/react-native/pull/297)\n\n![](/img/2020/15865050073779.jpg)\n\n看上去，微软这个库支持Mac啦，我带着惊喜的心情做了如下尝试，结果发生了这些事情：[issues](https://github.com/microsoft/react-native/issues/299)\n\n最终，通过各种猜测尝试，微软的这个库在macOS下终于跑起来了（顺便还在本地搭起了npm私服，虽然只有一个package......）\n\n![](/img/2020/15865180851593.jpg)\n\n##### 私服的小插曲\n\n在用**Verdaccio**为**ms-rn**搭私服的过程中，还遇到个问题，就是当我直接把微软的代码pull到本地publish到私服去用时，cli竟然是拉的**0.60.0-microsoft.67**版本，就算指定了最新的latest，`react-native init AwesomeApp`也是执行失败，后来意识到私服上没有这个版本，于是切到tag里疯狂的publish了一顿，最终初始化成功\n\n![](/img/2020/15865185436520.jpg)\n\n\n#### 工程相关\n\n[Letsnote](https://github.com/Readseek/Letsnote)\n\n结果还是比较理想的，简单的开发体验非常友好，另外Electron体积大的问题，RN方案算是质的飞跃，即使demo也要12.8 MB\n\n![](/img/2020/15865181723657.jpg)\n\n\n### 资料\n\nhttps://simulatedgreg.gitbooks.io/electron-vue/cn/\nhttps://juejin.im/entry/5c64db9851882562851b328f\nhttps://github.com/microsoft/react-native/pull/291\n\n\n","tags":["前端","跨端"],"categories":["科技"]},{"title":"用Reduce将数组变成带特定键值的对象","url":"/tech/reduce-array-to-object.html","content":"\n### Reduce\n\n出自**ES6**的Array，用来做累加的。以前我一直用来做算术求和，直到前一阵子看到了一个骚操作，于是又做了一番折腾...\n\n看这段代码先：\n\n```\nconst names = ['jack', 'pony', 'tony', 'thomas'];\nconst entry = names.reduce((prev, cur) => {\n    prev[cur] = `My full name is ${cur} ma.`;\n    return prev;\n}, {});\n```\n\n结果：\n\n```json\n{ jack: 'My full name is jack ma.',\n  pony: 'My full name is pony ma.',\n  tony: 'My full name is tony ma.',\n  thomas: 'My full name is thomas ma.' }\n```\n\n把一个数组转成了对象，如此优雅的操作。试想，不用这个如何达到效果！？\n\n```\nconst names = ['jack', 'pony', 'tony', 'thomas'];\nconst obj = {};\nfor (let name of names) {\n    obj[name] = `My full name is ${name} ma.`\n}\n```\n\n此时，多定义了一个变量，用了一层循环，看起来很没科技感。戳到API，我们可以看到它是这么定义的：\n\n```typescript\nreduce(callbackfn: (previousValue: T, currentValue: T, currentIndex: number, array: T[]) => T, initialValue: T): T;\n```\n\n是的，第二个参数竟然是泛型。之前一直传数字做累加，今天记住了。reduce功能不止于此。\n\n","tags":["javascript"],"categories":["科技"]},{"title":"移动端Web适配手记","url":"/tech/mobile-web-develop-notes.html","content":"\n### 写在开头\n\n这篇文章所谈到的内容非常基础，如果你已经是一个前端老司机了，请直接掉头加足油门离去。\n\n### 科普\n\n![](/img/2019/15591193255276.jpg)\n\n\n##### REM\n\nCSS3新增的一个相对单位，来自2013年。全称：`font size of root element`。可根据网页根元素来设置网页中其他字体大小。\n\n其中根元素指**html**标签，即：在`html标签里设置font-size属性，以此来作为其他rem值的基准，从而取得自适配平衡`。另外除了用来设置字体大小，rem还可用来设置视图的：width，height，margin，padding...\n\n##### EM\n\n作用与REM类似，但早于REM，算是他的前辈。全称：`font size of element`。相对于当前对象内文本的字体尺寸。如当前对行内文本的字体尺寸未被人为设置，则相对于浏览器的默认字体尺寸。其特点如下：\n\n- em值并不是固定的；\n- em会继承父级元素的字体大小；\n\n使用rem为元素设定字体大小时，仍然是相对大小，但相对的是HTML根元素。而em是相对于父级元素；\n\n\n### 与PX的转换\n\n> px像素（Pixel），相对长度单位。是相对于显示器分辨率而言。\n \n目前对于大部分浏览器，如果不修改相关字体配置，都是默认显示**font-size:16px**，于是和rem的映射关系有：`16px = 1rem`。\n\n\n```css\nhtml {\n    font-size: 16px;\n}\n```\n\n如果想给一个p标签设置12px的字体大小，那么用rem表示就是\n\n```css\np {\n    font-size: 0.75rem; // 12/16=0.75(rem)\n}\n```\n\n单位转换的工具：[pxtoem](http://pxtoem.com/)\n\n### 移动端的适配\n\n#### media queries\n\n最早，我刚接触响应式那会儿，是通过**css3的media queries**来获取当前设备屏幕尺寸，然后对应写几套css。但这玩意的副作用就是代码量很大，维护不方便（为了兼顾大屏幕或高清设备，会造成其他设备资源浪费，特别是加载图片。毕竟加载流量和时间也是要成本的）。代表作：**Bootstrap**\n\n#### flex或百分比（%）\n\n号称弹性布局的就是。查得资料所言，大部分套路皆为：flex+百分比的布局方式。另外，不需要适配的地方仍然是px单位。\n\n其中，百分比是相对于父元素，正常情况下是通过属性定义自身或其他元素\n\n#### rem（本文主角）\n\n> 这个特性目前主流浏览器都支持，可以放心用。适配步骤：\n\n##### 1. viewport设置\n\n```html\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0\">\n```\n\n其中width=device-width用于设置viewport的宽度等于屏幕的宽度，initial-scale=1.0, maximum-scale=1.0的作用同width=device-width一样\n\n之所以还要同时设置这两者，是因为当它们单独使用时，表现不够完美，即单独使用时，浏览器会有兼容性问题。另外当两者值不同时，浏览器取最大者。\n\n##### 2. 动态设置<html>元素的font-size值。一般有俩姿势：\n\n- 利用css的**media query**来设置，好处是都是在样式表里，好管理；\n- 利用**javascript动态操作dom属性来计算基准值**；\n\n样式设置\n\n```css\n@media (min-device-width : 375px) and (max-device-width : 667px) and (-webkit-min-device-pixel-ratio : 2){\n    html{font-size: 37.5px;}\n}\n```\n\n脚本设置\n\n```javascript\ndocument.getElementsByTagName('html')[0].style.fontSize = window.innerWidth / 10 + 'px';\n```\n\n> 这里除以10，是为了控制数字不至于太大，便于后边计算，是随便定义的。即定义屏宽为：10rem，10rem * font-size = 设计宽度\n\n##### 3. 编写统一的计量单位值\n\n在编写CSS元素时，width/height，margin，padding等时，使用**rem**作为单位。换算方式如上文提到的那样。可以参考以下公式：\n\n**具体属性值** = **设计稿上的标注** / **设计稿的宽度**\n\n当然如果你是使用诸如Less这样的动态样式表语言的话，可以参考下边说的操作。这样就计算出设计稿上的元素和设计稿的比例了。\n\n### 在Less中的应用\n\n为了统一尺寸计算，可以造一个新的单位，比如：wem\n\n```javascript\nmodule.exports = {\n    /**\n     * 基础尺寸换算。(eg in less: wem(1px))\n     * @param less\n     * @param pluginManager\n     * @param functions\n     */\n    install(less, pluginManager, functions) {\n        functions.add('wem', function(data, base) {\n            const bem = base ? base.value : 36;\n            return less.dimension(data.value / bem, 'rem');\n        });\n    },\n};\n```\n\n在公共的less文件中，可以引用以上插件：\n\n```less\n@plugin \"less-plugin\";\n\n// 外部的使用方式，直接用设计稿尺寸\n@contentWidth: wem(360);\n@padding: wem(10);\n```\n\n此时的360为设计稿的宽度，less插件中的默认36是以设计稿360px为准的，如果你是640px，换成64即可\n\n### 延伸\n\n#### DPR\n\n设备像素比（device pixel radio），设备像素比（dpr） = 设备像素（分辨率）/设备独立像素（屏幕尺寸）。用人话说，就是常说的2倍图、3倍图中的那个数字倍数\n\n一般情况下，我们设置`initial-scale=1.0`就可以了，但是对于dpr大于1的，我们还需要精细化一波操作，可以用**window.devicePixelRatio**获取当前设备的dpr，然后动态设置`viewport`\n\n```javascript\nlet drp = window.devicePixelRatio;\nmeta.setAttribute('content', 'initial-scale=' + 1/dpr + ', maximum-scale=' + 1/dpr + ', minimum-scale=' + 1/dpr + ', user-scalable=no');\n```\n\n如此，配合rem，就可以完全按设计稿标注来了，也不用再除以2、除以3。好处是：\n\n- 解决了图片高清的问题；\n- 解决了border 1px的问题。比如设置了viewport的scale为0.5，在2倍屏下，1px的border就被缩放成0.5px，更为细腻；\n\n#### VW  VH VM\n\n视口单位（Viewport units），之前写Vue时偶然发现的。是相对于视窗的宽高度，值为100。VM（VMin），即：取决于哪个更小\n\n对于移动端而言，最重要的是如何多终端兼容。以上介绍的响应式也好、REM也好都各有千秋，而REM使得CSS和JS耦合在了一起。**VW**和**VH**的诞生解决了这一难题，目前来看，是最趋于完美的做法。具体做法参考以下资料：\n\n### 参考资料： \n\n- [移动web适配利器-rem](http://www.alloyteam.com/2016/03/mobile-web-adaptation-tool-rem/)\n- [掘金：移动端/web端适配方案](https://juejin.im/post/5cbdee71f265da03b57b5866)\n- [视区相关单位vw, vh..简介以及可实际应用场景](https://www.zhangxinxu.com/wordpress/2012/09/new-viewport-relative-units-vw-vh-vm-vmin/)\n- [vh,vw单位你知道多少？](https://juejin.im/entry/59b00e46f265da2491513bcc)\n- [利用视口单位实现适配布局](https://aotu.io/notes/2017/04/28/2017-4-28-CSS-viewport-units/)\n\n#### 在线DEMO\n\n- [REM布局 - 淘宝聚划算](https://jhs.m.taobao.com/m/index.htm#!all)\n- [视口单位布局](https://jdc.jd.com/demo/ting/vw_layout.html)\n\n","tags":["前端","web"],"categories":["科技"]},{"title":"重新归置了一下标签体系","url":"/huma/the-optimization-about-tags.html","content":"\n### 标签\n\n> 人的一生，最多能被贴多少标签，又有多少是专属的，这是一个值得胡思乱想的问题...\n\n由于之前说IT博客的文章分类比较乱，今天周末，就来梭哈一下。弄完看了看，发现还挺有意思，不知不觉诱发了我的胡思乱想症\n\n见过有的同学搞博客，恨不得把`好123`的栏目全搞一遍，很少有人把`减法`做的很美...让我想起之前看到的一个故事，说是**老外设计一个产品时，往往只需要满足一个或很少几个核心`Tag`即可；而大多数国人则更倾向于搞一个大而全的产品，恨不得大家就用我的，其他可以卸载了一样...**\n\n我记得之前有人在Github提[Bug](https://github.com/tangkunyin/hexo-theme-jsimple/issues/31)说，JSimple配置太多导航，在小屏机就出问题了。事实上我老早就知道，我故意没修复而已，就是想提醒诸位：**做减法**啊，其实都是可以归纳提炼的。~~好吧，我承认我懒。哈哈~~\n\n\n```yml\ndefault_category: 技术\ncategory_map:\n   技术: tech-notes\n   人文: humanities\n   其他: others\ntag_map:\n  ## language tags\n  dart: dart\n  swift: swift\n  objective-c: oc\n  java: java\n  python: py\n  javascript: js\n  typescript: ts\n  ## platform tags\n  苹果: ios\n  安卓: android\n  麦克: mac\n  ## frameworks\n  vue: vue\n  react: react\n  flutter: flutter\n  react-native: rn\n  hexo: hexo\n  ## client tags\n  后端: back-end\n  前端: front-end\n  跨端: cross-app\n  ## others\n  读书: reading\n  旅行: traveling\n  码常规: dev-tips\n  黑科技: cool-tech\n  碎碎念: impression\n```\n\n如上所示，这次将几个核心技能组合了下，之于`WebX`这个神器的标签，我今天刚发明的。因为叫Web2.0吧，过一阵还得换成Web3.0，4.0，5.0...最后还得是X或XS Max\n\n我在想，当我不写码的时候，是否可以做到熟练掌握这些标签，如果可以。则不枉一代优秀的程序员。这些标签也时刻提醒我自己，在技术上别太偏离轨道...\n\n### 人文\n\n人的标签其实也一样，比如常说的**首富**这个标签，大家自然会想起：互联网二马老师，房事界王老师等人...\n\n被赋予公认社会标签的价值和拯救地球的能力成正比，对于那种专属标签，普通人恐怕一辈子都难以得到。我们普通人要做的，恐怕还是做减法，努力让自己成为某个领域那拥有一个标签的人，而不是那种大而全的人......\n\n我是：儿子，爸爸，写手，老公，90S，私企员工，码农，未来De企业家.....你呢？\n\n","tags":["碎碎念"],"categories":["人文"]},{"title":"Preact入坑笔记一","url":"/tech/Preact-learning-notes1.html","content":"\n### 简述\n\n**Preact**，读：`['pri:ækt]`，而非`批React`。跟Pure React也扯不上什么关系。\n\n是由谷歌的一~~群~~大兄弟开发和维护的优化版`React`。这并非造个轮子要取代FB的`React`，通过一些资料和实践，发现这个轮子并不简单。具体可以链接到官网，中文说明足够友好，作者真是太赞了。\n\n官方：[Preact官网](https://preactjs.com/)\n项目地址：[Preact](https://github.com/developit/preact)\n\n![](/img/2019/15487547031177.jpg)\n\n\n### 实践笔记，第一部分\n\n这也并非是近期的新鲜事物，只是我个人刚接触罢了。从这一个月的使用看来，这个确实比React简单一些。比如核心库直接去掉了`PropTypes`这种东西，对`Render`也进行了优化，搭配`TypeScript`和`Less`使用，爽的么法...\n\n#### 一. 这里记录下开发环境的配置，主要依赖情况：\n\n- Preact: ^8.2.6\n- typescript: ^3.2.4\n- Less: ^3.9.0\n- Webpack: ^4.29.0\n\n```json\n\"scripts\": {\n        \"dev\": \"NODE_ENV=development webpack-dev-server --config scripts/webpack.config.js\",\n        \"build\": \"NODE_ENV=production webpack --config scripts/webpack.config.js\",\n        \"ts-build\": \"tsc --pretty --outDir ./modules\",\n        \"ts-watch\": \"tsc -w --pretty --outDir ./modules\",\n        \"pm2-dev\": \"pm2 start npm --name prdemo -- run dev && npm run ts-watch\",\n        \"pm2-clear\": \"pm2 delete prdemo\"\n    },\n    \"husky\": {\n        \"hooks\": {\n            \"pre-commit\": \"lint-staged\"\n        }\n    },\n    \"lint-staged\": {\n        \"linters\": {\n            \"*.{js,jsx,md,json}\": [\n                \"prettier --write\",\n                \"git add\"\n            ],\n            \"*.{ts,tsx}\": [\n                \"prettier --write\",\n                \"tslint --fix\",\n                \"git add\"\n            ],\n            \"*.css\": [\n                \"stylelint --fix\",\n                \"git add\"\n            ],\n            \"*.less\": [\n                \"stylelint --fix --syntax=less\",\n                \"git add\"\n            ]\n        },\n        \"ignore\": [\n            \"./modules/**\"\n        ]\n    },\n    \"eslintConfig\": {\n        \"extends\": \"eslint-config-aerian\"\n    },\n    \"eslintIgnore\": [\n        \"build/*\"\n    ],\n    \"stylelint\": {\n        \"extends\": \"stylelint-config-standard\",\n        \"rules\": {\n            \"indentation\": 4,\n            \"number-leading-zero\": null,\n            \"at-rule-no-unknown\": [\n                true,\n                {\n                    \"ignoreAtRules\": [\n                        \"plugin\"\n                    ]\n                }\n            ],\n            \"selector-pseudo-class-no-unknown\": [\n                true,\n                {\n                    \"ignorePseudoClasses\": [\n                        \"global\"\n                    ]\n                }\n            ]\n        }\n    },\n    \"dependencies\": {\n        \"preact\": \"^8.2.6\"\n    },\n    \"devDependencies\": {\n        \"@types/jest\": \"^23.3.13\",\n        \"@types/node\": \"^8.10.38\",\n        \"copy-webpack-plugin\": \"^5.0.0\",\n        \"css-loader\": \"^2.1.0\",\n        \"file-loader\": \"^3.0.1\",\n        \"html-webpack-plugin\": \"^3.2.0\",\n        \"husky\": \"^1.3.1\",\n        \"jest\": \"^24.0.0\",\n        \"less\": \"^3.9.0\",\n        \"less-loader\": \"^4.1.0\",\n        \"lint-staged\": \"^8.1.1\",\n        \"mini-css-extract-plugin\": \"^0.5.0\",\n        \"mkdirp\": \"^0.5.1\",\n        \"preact-async-route\": \"^2.2.1\",\n        \"preact-render-spy\": \"^1.3.0\",\n        \"preact-router\": \"^2.6.1\",\n        \"prettier\": \"^1.16.1\",\n        \"recursive-copy\": \"^2.0.10\",\n        \"style-loader\": \"^0.23.1\",\n        \"stylelint\": \"^9.10.1\",\n        \"stylelint-config-standard\": \"^18.2.0\",\n        \"ts-jest\": \"^23.10.5\",\n        \"ts-loader\": \"^5.3.3\",\n        \"tslint\": \"^5.12.1\",\n        \"tslint-config-prettier\": \"^1.17.0\",\n        \"tslint-consistent-codestyle\": \"^1.15.0\",\n        \"tslint-eslint-rules\": \"^5.4.0\",\n        \"tslint-react\": \"^3.6.0\",\n        \"typescript\": \"^3.2.4\",\n        \"typings-for-css-modules-loader\": \"^1.7.0\",\n        \"uglifyjs-webpack-plugin\": \"^2.1.1\",\n        \"url-loader\": \"^1.1.2\",\n        \"webpack\": \"^4.29.0\",\n        \"webpack-cli\": \"^3.2.1\",\n        \"webpack-dev-server\": \"^3.1.14\"\n    }\n```\n\n之所以加了`pm2`，是因为有两份`TypeScript`源码需要watch，`Webpack`本身watch占用一个console窗口，tsc自己也要有。如果一个命令启动，就会导致一个卡在另一个之前，导致另一个无法启动.....所以索性把webpack直接放到了后台。其本身作为Server服务，也算合理。不过正常情况，不会像我这么变态......\n\n#### 二. TSC\n\n```json\n{\n    \"compilerOptions\": {\n        \"charset\": \"utf8\",\n        \"sourceMap\": true,\n        \"rootDir\": \"./src/\",\n        \"outDir\": \"./modules\",\n        \"skipLibCheck\": true,\n        \"allowSyntheticDefaultImports\": true,\n        \"target\": \"es5\",\n        \"module\": \"es6\",\n        \"lib\": [\"es6\", \"es7\", \"dom\"],\n        \"allowJs\": false,\n        \"jsx\": \"react\",\n        \"jsxFactory\": \"h\",\n        \"strict\": true,\n        \"declaration\": true,\n        \"moduleResolution\": \"node\",\n        \"noImplicitAny\": false,\n        \"esModuleInterop\": false,\n        \"experimentalDecorators\": true,\n        \"removeComments\": false,\n        \"preserveConstEnums\": true\n    },\n    \"include\": [\"./src/**/*\"],\n    \"exclude\": [\n        \"docs\",\n        \"modules\",\n        \"typings\",\n        \"node_modules\"\n    ]\n}\n```\n\n注意`jsxFactory`使用的是`h`，这个`h`是`Preact`的核心之一\n\n#### 三. Less的一点问题\n\n1，正常使用import引用less时，IDE会报错提示`Cannot find module './style.less'.`。直接加`@ts-ignore`可以忽略，但不是好方法\n\n```\n// @ts-ignore\nimport style from './style.less';\n```\n\n如上所以，解决方式也很简单：第一新建`less.d.ts`文件，第二在该文件内申明`less`\n\n```\ndeclare module \"*.less\";\n```\n\n然后，在基类中引用，注意不是import，而是**reference**指令\n\n```\n/// <reference path=\"../../typings/less.d.ts\" />\n```\n\n2，组件上，用点语法使用less的选择器。但又得注意，`style.className`的值是随机字符串，并非对象，因此不能接着点（内层嵌套拿不到值），即：`style.className.Name1`非法\n\n```less\na {\n    &.normal {\n        color: #333;\n    }\n    &.active {\n        color: #fff;\n    }\n}\n```\n\n以上用法如下：\n\n```html\n<nav class={isActive ? style.active : style.normal}>{txt}</a>\n```\n\n#### 四. Preact无状态组件使用\n\n```typescript\nimport {FunctionalComponent, h} from 'preact';\nimport style from './style.less';\n\ninterface INavProps {\n    transparent?: boolean,\n    title?: string,\n    onBack?: (index) => void\n    onHome?: (index) => void,\n    onShare?: (index) => void\n}\nexport const Navigator: FunctionalComponent<INavProps> = ({transparent, title, onBack, onHome, onShare}) => {\n    const onBackPress = (e) => {\n        if (onBack) {\n            onBack(e);\n            return;\n        }\n        // TODO.\n    };\n    const onHomePress = (e) => {\n        if (onHome) {\n            onHome(e);\n            return;\n        }\n        // TODO.\n    };\n    const onSharePress = (e) => {\n        if (onShare) {\n            onShare(e);\n            return;\n        }\n        // TODO.\n    };\n    const className = transparent ? style.transparent : style.normal;\n    return (\n        <nav class={className}>\n            <button class={className} onClick={onBackPress} />\n            <span class={className}>{title}</span>\n            <button class={className} onClick={onHomePress} />\n            <button class={className} onClick={onSharePress} />\n        </nav>\n    );\n};\n```\n\n#### 五. 其他方面\n\n由于着手的这项目有点怪，所以自制了一款webpack插件，其中有用到了`recursive-copy`。需要把指定文件夹里的非TS和TSX拷贝到另外的目录，配置其`filter`时曾让人蛋疼不已.....具体请看[minimatch](https://github.com/isaacs/minimatch#usage)。结论是这玩意跟一般正则不一样，当时按正则咋配咋不对\n\n```\n// 过滤ts和tsx\nconst OPTIONS = {\n    overwrite: true,\n    expand: true,\n    dot: true,\n    filter: ['**/*.!(tsx|ts)'],\n};\n```\n\n### 扩展阅读：\n\n- [Preact：一个备胎的自我修养](https://juejin.im/post/5a0191f25188254de1699b0b)\n- [TS-Preact](https://dominicstpierre.com/how-to-start-with-typescript-and-preact-a9ea3e0ba4dc)\n- [preact-material-components](https://github.com/prateekbh/preact-material-components)\n\n","tags":["前端","react","typescript"],"categories":["科技"]},{"title":"引入Gulp压缩整站资源进一步提高写作效率","url":"/tech/use-gulp-to-speed-hexo.html","content":"\n### 这篇文章基于`JSimple`最新版\n\n上一篇的更新日志：[The-Update-for-JSimple-in-Early2019](https://blog.tangkunyin.com/tech/the-update-for-jsimple-in-early2019-1547728233.html)\n\n其实关于本文主题，Google一下文章到处都是，然而我找了几篇都是`gulp3`，对于我这种忍不了旧习的人来说当然不行，于是，我一把梭的弄了`gulp4`\n\n#### 依赖情况\n\n```json\n\"scripts\": {\n    \"prepublish\": \"hexo clean && hexo g && gulp\",\n    \"publish\": \"hexo d && hexo b\"\n  },\n  \"dependencies\": {\n    \"@babel/core\": \"^7.2.2\",\n    \"@babel/preset-env\": \"^7.2.3\",\n    \"gulp\": \"^4.0.0\",\n    \"gulp-babel\": \"^8.0.0\",\n    \"gulp-htmlclean\": \"^2.7.22\",\n    \"gulp-htmlmin\": \"^5.0.1\",\n    \"gulp-imagemin\": \"^5.0.3\",\n    \"gulp-minify-css\": \"^1.2.4\",\n    \"gulp-uglify\": \"^3.0.1\",\n    \"hexo\": \"^3.7.0\",\n    \"hexo-deployer-git\": \"^0.3.1\",\n    \"hexo-generator-archive\": \"^0.1.5\",\n    \"hexo-generator-baidu-sitemap\": \"^0.1.6\",\n    \"hexo-generator-category\": \"^0.1.3\",\n    \"hexo-generator-index\": \"^0.2.1\",\n    \"hexo-generator-search\": \"^2.4.0\",\n    \"hexo-generator-sitemap\": \"^1.2.0\",\n    \"hexo-generator-tag\": \"^0.2.0\",\n    \"hexo-git-backup\": \"^0.1.2\",\n    \"hexo-renderer-ejs\": \"^0.3.1\",\n    \"hexo-renderer-marked\": \"^0.3.2\",\n    \"hexo-renderer-stylus\": \"^0.3.3\",\n    \"hexo-server\": \"^0.3.2\"\n  }\n```\n\n新增的`scripts`操作，是在写完文章时便于梭哈。之于区分`prepublish`和`publish`，是想提醒各位，上线之前先检查下 ：）\n\n#### Gulp任务\n\n站点根目录新建：`gulpfile.js`\n\n```javascript\nvar gulp = require('gulp');\nvar minifycss = require('gulp-minify-css');\nvar uglify = require('gulp-uglify');\nvar htmlmin = require('gulp-htmlmin');\nvar htmlclean = require('gulp-htmlclean');\nvar imagemin = require('gulp-imagemin');\n\n// 引入babel，万一用了ES6呢\nvar babel = require('gulp-babel');\n\ngulp.task('minify-html', function() {\n    return gulp.src('./public/**/*.html')\n        .pipe(htmlclean())\n        .pipe(htmlmin({\n            removeComments: true,\n            collapseWhitespace: true,\n            collapseBooleanAttributes: true,\n            removeEmptyAttributes: true,\n            removeScriptTypeAttributes: true,\n            removeStyleLinkTypeAttributes: true,\n            minifyJS: true,\n            minifyCSS: true\n        }))\n        .on('error', function(err) {\n            console.log('html Error!', err.message);\n            this.end();\n        })\n        .pipe(gulp.dest('./public'))\n});\ngulp.task('minify-css', function() {\n    return gulp.src('./public/**/*.css')\n        .pipe(minifycss())\n        .pipe(gulp.dest('./public'));\n});\ngulp.task('minify-js', function() {\n    return gulp.src(['./public/js/**/*.js', '!./public/js/**/*.{min,mini}.js'])\n        .pipe(babel())\n        .pipe(uglify())\n        .pipe(gulp.dest('./public/js'));\n});\ngulp.task('minify-images', function() {\n    return gulp.src('./public/img/**/*.*')\n        .pipe(imagemin(\n        [imagemin.gifsicle({'optimizationLevel': 3}),\n        imagemin.jpegtran({'progressive': true}),\n        imagemin.optipng({'optimizationLevel': 8}),\n        imagemin.svgo()],\n        {'verbose': true}))\n        .pipe(gulp.dest('./public/img'))\n});\ngulp.task('default', gulp.parallel('minify-html','minify-css','minify-js','minify-images', function(done){\n    done();\n}));\n```\n \n \n####  Babel大法，毕竟你不能保证在激动时不用ES6（主要是这货uglify对此不友好）\n \n 站点根目录新建：`.babelrc`\n \n ```json\n {\n    \"presets\": [\"@babel/env\"]\n }\n ```\n \n \n#### 验证一下\n\n![](/img/2019/15480009042280.jpg)\n\n如果没有报错，就很没问题了！目前为止，暂时没发现有不对的地方。嗯，跪求打脸...\n\n👀️提醒我该休息了，大新闻到此为止。明天中文多打一份荤菜奖励自己......晚安 ~ 😴️\n\n","tags":["hexo","web"],"categories":["科技"]},{"title":"The-Update-for-JSimple-in-Early2019","url":"/tech/the-update-for-jsimple-in-early2019.html","content":"\n\n![JSimple-Snapshot-Macbook Pro15](/img/2019/JSimple-Snapshot-Macbook%20Pro15.png)\n\n\n### 效果如上， 更新日志如下：\n\n- 修复夜间模式下，一直被诟病的代码高亮部分空白；\n- 修复返回顶部按钮在Chrome下失效的问题；\n- 新增文章置顶功能；\n- 新增DNS预取条目，尽可能为站点提速；\n- 替换搜索模块，使用新的本地搜索，内容关键词也可高亮；\n- 优化404描述页若干；\n- 替换统计模块为**Google Analysis**；\n- 新增文章，分类，标签等处**Google AdSense**，为大客户提供方便的流量套现操作；\n- 新增图片懒加载操作；\n- 新增作者统一配置，即优先读文章作者，其次主题作者；\n- 国际化(i18N)优化；\n- 去掉丑陋的滚动条；\n- 优化文字样式、对其方式、屏宽若干；\n- 优化配置字段，去掉不必要的配置项；\n- 页脚链接优化，增加网站地图；\n- 合并资源文件，减少http请求（搭配Gulp效果更好）；\n\n### 下边对部分模块分别说明\n\n#### 1. 搜索\n\n由于旧版本（`< 0.0.7`）的搜索，有样式问题，且无法检索文章内容，关键词也无法高亮。此次更新引入`Next`主题的`Local-Search`。\n\n`JSimple`对此进行了二次修改，改进了搜索函数不合理或者有潜在问题的地方。新增键盘流操作。**`正常浏览时，按F键可迅速唤起搜索；再按ESC可关闭搜索`**。~~理想的交互下，应该使用方向键控制检索结果的选择，无奈改动较大，没有足够的时间精力投入，暂且放弃治疗~~\n\n需要注意的是，搜索需要引入：`hexo-generator-search`库，它将为检索内容提供数据保障\n\n#### 2. 置顶\n\n`Hexo`是静态站，没法做到类似`WP`那样后台配置一下就能顶。因此这个操作只能在生成静态HTML时做改变。\n\n新版本目录中，增加了`patch`操作，其中`generator.js`就是置顶逻辑处理。需要将其替换到对应目录中，置顶方能生效。\n\n另外两个文件，是对文章增加了`timestamp`字段，用在配置文章地址时。一般安装主题后，执行一下：`./run.sh`即可。当`node_modules`不慎删除或迁移站点后，页需要执行一次。\n\n#### 3. 广告\n\n> 策略如下\n\n1. 首页列表间：使用自动广告，一般会出现在分类列表中间。考虑到首页加载速度与体验及展示量，特使用自动广告取平衡，即：随缘展示。\n2. 归档页：首部横向自适应广告\n3. 标签页：尾部横向自适应广告\n4. 文章页：分布两侧，以及末尾。 \n\n为什么用`AdSense`，个人基于以下几点：\n\n1. 域名无需备案就能用；\n2. 覆盖面广，如果你是针对这个地球的读者，那目前没有比它合适的；\n3. 美元到帐，收益可观；\n4. 广告质量相对人性化和底线化；\n\n当然，如果观人不喜欢`Google套装`，请其自力更生...\n\n#### 4. 加速\n\n本次将可以合并的资源，写到了一个文件。如对`JQuery`的引用不再是从CDN拉。引入`DNS-Prefetch`操作，尽可提高响应速度。\n\n关于Gulp压缩资源的操作，请参考这边文章：[引入Gulp压缩整站资源进一步提高写作效率](https://blog.tangkunyin.com/tech/use-gulp-to-speed-hexo-1547999542.html)\n\n#### 5. 将来\n\n+ ~~Disqus新增局部刷新操作~~\n+ ~~搜索结果支持方向键选择~~\n+ ~~更爽的移动端视觉及交互~~\n\n\n拖了一个大礼拜，置顶了一大周，终于「象征性」的补完了.... 😅😅😅\n\n![](/img/2019/15486045964350.jpg)\n\n\n","tags":["hexo","web"],"categories":["科技"]},{"title":"一直在加油从未中大奖","url":"/huma/always-refueling-but-never-awards.html","content":"\n\n### 年会那点事...\n\n今年的年会，是第一次没去现场，可能也永远不会再去现场。毕竟山高皇帝远了...\n\n往年，都是起得早早的，收拾的美美的。然后幻想着，能被运气照顾下，毕竟自己的工号数字很吉利。然而，每次都和大奖擦肩而过😅\n\n屏幕这端看着直播，那边同事个个都是坐拥豪华大奖而归，而我只有下边那个...\n\n![WechatIMG44](/img/2019/WechatIMG44.jpeg)\n\n\n![WechatIMG45](/img/2019/WechatIMG45.jpeg)\n\n\n\n想起前段时间朋友圈里看到的一个段子，大意如下：\n\n> 上帝是公平的，给别人幸福的同时也会遮住你的眼，怕你看见心里难受\n\n如果没有遮住你的眼，自己闭上就好了。做人嘛，开心最重要！\n\n\n### 当然，上面都是段子。重点来了...\n\n##### **赶紧去咸鱼啊，巴拉巴拉的平台。找自己需要的物品，全新未拆封，总有一款适合你**\n\n来年，继续加油...嗯，新年快乐！\n\nHappy New Year.\n\nAlways belive yourself that good things will come in soon\n\n... Just for fun😊\n\n\n\n\n\n\n\n","tags":["碎碎念"],"categories":["人文"]},{"title":"自执行匿名函数IIFE","url":"/tech/iife-notes.html","content":"\njs大法也玩了好几年。但今天读到一篇文章，提到了一个词：**`IIFE`**，立马傻眼了，这什么鬼...\n\n于是谷歌了一梭...原来就是个自动执行的函数表达式。**`Immediately-Invoked Function Expression`**\n\n一句话概括就是：定义时就会立即执行的  JavaScript 函数。以下来自`mozilla`的权威解释\n\n> 这是一个被称为 自执行匿名函数 的设计模式，主要包含两部分。\n> > 第一部分是包围在 圆括号运算符() 里的一个匿名函数，这个匿名函数拥有独立的词法作用域。这不仅避免了外界访问此 IIFE 中的变量，而且又不会污染全局作用域；\n> > 第二部分再一次使用 () 创建了一个立即执行函数表达式，JavaScript 引擎到此将直接执行函数。\n\n在 Javascript 中，圆括号**()**是一种运算符，跟在函数名之后，表示调用该函数。比如，`print()`就表示调用`print`函数。\n\n### 话不多说，看代码\n\n```javascript\n/**\n * 1. 当一个函数变成IIFE时，其内部的变量不能从外部访问\n */\n(function(){\n    var name = 'Jack';\n})();\n\n// 外部不能访问变量 name\nconsole.log(name); // undefined\n\n/**\n * 2. 将 IIFE 分配给一个变量，不是存储 IIFE本身，而是存储其执行后返回的结果\n */\nvar result = (function(){\n    var name = 'Jack';\n    return name + ' love Rose';\n})();\n\n// 此时，IIFE就是一个变量，而不是函数\nconsole.log(result); // Jack love Rose\n```\n\n### 结论及用途\n\n\n- 需要有括号包起来，且两个IIFE连着写时，需要加分号；\n- 省略函数命名，避免污染全局变量；\n- IIFE内部形成单独的作用域，可以封装一些外部无法读取的私有变量；\n\n#### 一个小知识点\n\n```javascript\n// case1\nfor (var i = 0; i < 5; i++) {\n    setTimeout(function() {\n        console.log(i);\n    }, 1000 * i)\n}\n// case2\nfor (let i = 0; i < 5; i++) {\n    setTimeout(function() {\n        console.log(i);\n    }, 1000 * i)\n}\n```\n\n上面的case1和case2，结果分别是什么？为什么？在看下面：\n\n```javascript\n// case3\nfor (var i = 0; i < 5; i++) {\n    (function(i) {\n        setTimeout(function() {\n            console.log(i);\n        }, 1000 * i);\n    })(i);\n}\n```\n\n> case2和case3均打出：0,1,2,3,4。而case1，则：5,5,5,5,5\n\n\n嗯，神奇现象之：let-for搭配...块作用域的应用\n\n\n","tags":["javascript"],"categories":["科技"]},{"title":"Typescript入坑篇2","url":"/tech/ts-study-part2.html","content":"\n### 规范相关\n\n> 题外话，今天突然意识到文章英文标题好像有点怪...`ts-study`，当时为啥不写成`ts-learning`呢，明显感觉后者读起来更爽口啊😂️\n\n资料：\n\n- [入坑篇1（前置操作）](https://blog.tangkunyin.com/tech/ts-study-part1-1528259629.html)\n- [自定义 tslint & eslint 详细规则](https://juejin.im/post/5b3859a36fb9a00e4d53fc85)\n- [官方语法基础](https://www.tslang.cn/docs/handbook/basic-types.html)\n- [Typescript Guidelines](https://semlinker.com/ts-intro-and-guide/)\n- [TypeScript Handbook（中文版）](https://zhongsp.gitbooks.io/typescript-handbook/)\n- [深入理解 TypeScript](https://jkchao.github.io/typescript-book-chinese/)\n- [awesome-typescript](https://github.com/semlinker/awesome-typescript)\n\n\n\n\n### 编码相关\n\n> 由于官方及其他资料在这方面非常详细了，本文不作基础内容的赘述。这里假定读者已经学习了基础的语法，如`基础类型`、`变量声明等`......\n\n#### 1. 新建`ts`文件\n\n可以选择在项目的根目录建立`src`目录，然后新建`index.ts`文件\n\n```typescript\ntype CallBack = (value?: string) => void;\n\ninterface Config {\n    name: string\n    age: number\n    todo?: CallBack\n}\n\nexport default class Person {\n\n    init: Config\n\n    constructor(init?: Config) {\n        if (init) {\n            this.init = init;\n            this.init.todo = init.todo || ((value?: string) => {\n                console.log(value || 'This person have been created...But nothing todo')\n            })\n        }\n    }\n\n    public todoSomething() {\n        // this.init.todo();\n        this.init.todo('Hello World. Welcome to learn TypeScript');\n    }\n}\n```\n\n\n#### 2. 配置编译选项`tsc`、文档生成、头文件等\n\n```json\n\"scripts\": {\n    \"tsc\": \"tsc\",\n    \"dev\": \"npm run tsc -w\",\n    \"types\": \"tsc -d --emitDeclarationOnly --allowJs false --declarationDir ./@types\",\n    \"build\": \"build options...\",\n    \"prepush\": \"npm run tsc && npm run types\",\n    \"prepublish\": \"npm run prepush && npm run build\",\n    \"typingsdoc\": \"npx typedoc --out ./typings/doc  ./src/**/*.ts  --module umd\"\n}\n```\n\n其中这块的配置，在[part1](https://blog.tangkunyin.com/tech/ts-study-part1-1528259629.html)提到过，[包括同时生成头文件并允许js文件输入](https://blog.tangkunyin.com/tech/Allow--declaration-with--allowJs-1546511333.html)\n\n这里把新增加的，简要说明下：\n\n- dev: 监听.ts文件改动，实时编译。即增加`-w`参数可避免手动编译\n- prepush: 合并了两个命令，并且`git push`时，会被触发。以此可强制推送前编译最新代码\n- prepublish: 同样合并两个命令，在即将发布上线时使用\n- typingsdoc: 生成Api文档。关于这个，不清楚的读者请看这篇文章：[Typedoc使用笔记](https://blog.tangkunyin.com/tech/typedoc-notes-1544152560.html)\n\n#### 3. tslint及tsconfig\n\n```json\n// tslint.json\n{\n  \"defaultSeverity\": \"error\",\n  \"extends\": [\n    \"tslint:recommended\",\n    \"tslint-config-prettier\"\n  ],\n  \"rules\": {\n    \"encoding\": true,\n    \"no-console\": false,\n    \"object-literal-sort-keys\": false,\n    \"interface-name\": [true, \"never-prefix\"],\n    \"no-unused-expression\": [true, \"allow-fast-null-checks\"],\n    \"only-arrow-functions\": false,\n    \"no-duplicate-imports\": true,\n    \"no-mergeable-namespace\": true,\n    \"import-spacing\": true,\n    \"interface-over-type-literal\": true,\n    \"new-parens\": true,\n    \"no-shadowed-variable\": [\n      true,\n      {\n        \"class\": true,\n        \"enum\": true,\n        \"function\": true,\n        \"interface\": false,\n        \"namespace\": true,\n        \"typeAlias\": false,\n        \"typeParameter\": false\n      }\n    ],\n    \"variable-name\": false\n  }\n}\n\n// tsconfig.json\n{\n  \"compilerOptions\": {\n    \"charset\": \"utf8\",\n    \"sourceMap\": true,\n    \"allowSyntheticDefaultImports\": true,\n    \"target\": \"es5\",\n    \"moduleResolution\": \"node\",\n    \"module\": \"umd\",\n    \"outDir\": \"./built\",\n    \"experimentalDecorators\": true,\n    \"removeComments\": true,\n    \"preserveConstEnums\": true,\n    \"allowJs\": true\n  },\n  \"include\": [\n    \"src/**/*\"\n  ],\n  \"exclude\": [\n    \"node_modules\",\n    \"built\",\n  ]\n}\n```\n\n#### 4. 测试编译\n\n执行`npm run prepush`和`npm run typingsdoc`后。根目录下，应该多了俩目录：\n\n![](/img/2019/15469365443647.jpg)\n\nApi文档目录\n\n![](/img/2019/15469365901446.jpg)\n\n\n如果遵照第一篇的配置，加过`prettier`大法。会发现`src`下的源文件也被美美的调整了代码风格\n\n目前，暂时就这些。后边在整理，总结！！！\n\n","tags":["typescript"],"categories":["科技"]},{"title":"TS编译之一把梭生成@types和js","url":"/tech/Allow--declaration-with--allowJs.html","content":"\n### 先了解下情况\n\n如果`tsconfig.json`中，同时配置了如下操作：\n\n```json\n{\n  \"compilerOptions\": {\n    \"charset\": \"utf8\",\n    \"sourceMap\": true,\n    \"allowSyntheticDefaultImports\": true,\n    \"target\": \"es5\",\n    \"moduleResolution\": \"node\",\n    \"module\": \"umd\",\n    \"outDir\": \"./dist\",\n    \"experimentalDecorators\": true,\n    \"removeComments\": true,\n    \"preserveConstEnums\": true,\n    \"diagnostics\": true,\n    \"allowJs\": true,// 允许编译javascript文件\n    \"declaration\": true,//生成相应的 .d.ts文件（类似Objc中的.h文件）\n    \"declarationDir\": \"./@types\"//单独为头文件指定存放的位置\n  },\n  \"include\": [\n    \"src/**/*\"\n  ],\n  \"exclude\": [\n    \"node_modules\",\n    \"dist\"\n  ]\n}\n```\n\n从这里开始，allowJs如果为true，则declaration就不应该存在。否则你将会看到编译时如下的报错...\n\n> Option 'allowJs' cannot be specified with option 'declaration'.\n\n![](/img/2019/15465174447511.jpg)\n\n看目录，好像需要的也都生成了！\n\n![](/img/2019/15465177839896.jpg)\n\n但是作为一个优秀发程序员，能眼睁睁看到编译报错而不管嘛，当然不能！！！于是去撸`github`，发现早在2016年，微软那边就知道这事：[issues-7546](https://github.com/Microsoft/TypeScript/issues/7546)，但为毛现在还存在这个问题....\n\n于是看他们讨论~~互怼~~，无意中看到巴基斯坦一兄弟的姿势。果断试了下，哎，别说，行了....\n\n![](/img/2019/15465180905253.jpg)\n\n\n### 我把上边的操作整理了下，变成了一把梭，请看\n\n```json\n\"scripts\": {\n    \"tsc\": \"tsc\",\n    \"types\": \"tsc -d --emitDeclarationOnly --allowJs false --declarationDir ./@types\",\n    \"prepublish\": \"npm run tsc && npm run types\"\n},\n```\n\n于是，之后你需要执行`npm run prepublish`就可以了。前提是把下边这两句从`tsconfig.json`中干掉\n\n```json\n{\n    \"declaration\": true,\n    \"declarationDir\": \"./@types\"\n}\n```\n\n如果读者有更成熟的方案，麻烦告知。感谢！\n\n\n\n\n","tags":["typescript"],"categories":["科技"]},{"title":"一壶漂泊浪迹天涯南入喉","url":"/huma/Leave-Beijing-to-Nanjing.html","content":"\n![15462748322530](/img/2019/15462748322530.jpg)\n\n## 序\n\n听着Jay的歌、对着东南风，饮下这一壶漂泊，但也不知这一壶，还要喝多久......\n\n### 上半场\n\n差不多一个月前，我正式~~（此前已心里BB很多次）~~离开了漂泊六年之久的北京。来到了向往已久的南方城市 --- 南京，说实在的其实一直向往珠三角，没想到来的却是长三角，说来也怪，以前还从来没有对南京产生过想法，可能天意如此吧，哈哈！\n\n从2012年7月赴京到此时此刻已整整六年多，到现在还很清楚的记得刚来那些天。我是19号晚上坐火车上京的，到西站是20号的下午那会，当晚就是7.21暴雨。北京变成了水城，房山某些还发了洪水，近80人的生命没了......我则被大雨浇透全身，毫不夸张的说，连内裤都是湿的。当时打车去朋友住处途径积水潭，出租车司机都不想拉我走了（担心积水把发动机弄坏了）！当时那会还是很激动的，没有感到失望恐惧。毕竟到了首都\n\n作为一个一无所有，两袖清风的少年郎，我腰上别着两颗滚烫的肾，就开始了北漂生活。我的落脚点是二环小西天，但第二天起来就去五环外的西二旗参观了各大IT总部，包括联想、百度等~~（想笑就笑吧，毕竟事后我也觉得挺好笑）~~。而也就是在那以后，在五环外住了六年多。所以每当听郭德纲老师唱那首`五环之歌`时，我都特别感触。非常感谢李同学当年及一直以来的支持和帮助，虽然你可能早已忘了。这期间也遇到了一群很要好的亲友，大伙一起走过了很快乐的一些时光。另外Jobs层面手动感谢一下第X季、Echo、YBin、Champion、YY、Alfred等人，感谢生命中遇到的这些贵人......就让这六年的美好记忆定格，生活继续。所以你好、谢谢、再见！\n\n> 为什么是南京？\n\n我本身是倾向于四季如春而不是四季分明，因此在这个层面上，南京自然会有一些优势。除了气候原因，另外就是帝都那让普通人望而却步的房价和户口机制......当然说这些只能证明自己的无能。北京的冬天很冷，冷到外边树叶全部掉光，冷到外出不戴口罩脸都能冻掉。基本上在那种地方，更多的时间只能是待在出租屋里，让人很抑郁。同大多数北漂朋友一样，我非常讨厌搬家。当得知房东老哥的一句话后（老弟，房子明年我要自己住，麻烦你...）立马就下了南迁的决心。因为实在不想再找地方搬家，另外有南迁的机会，这个时间点非常碰巧，貌似老天暗中推了我一把，真是为我量身定制！\n\n长三角，这个集群地带。不论是发展还是生活，都非常吸引人。这里有着上有天堂下有苏杭的美誉，气候温润、青山绿水，起码冬天出去到处也是绿油油的。这是北京永远给不了的福利.....\n\n所以离开，不是说不好，只是不适合自己。用一句话总结上半场：让我们微笑离开让故事留下来~\n\n\n### 下半场\n\n来这边快一个月了，体验非常好。特别是上下班时间被严重压缩，第一次感受到事业和生活是可以取平衡的，不像之前总在路上奔命......\n\n新的一年，立几个Flag，我希望：\n\n- 把18年京东618买的几十斤书看完；\n- 每周一篇文章，不管是技术笔记还是瞎扯淡，希望能坚持码字；\n- 持续学英语，学会弹钢琴，成为自己想成为的那个人；\n- 走遍长三角（如果不行，走遍南京市也可以）；\n\n\n### 最后\n\n隔壁的老王，希望你新的一年身体健康、万事如意。早日南下团聚......\n\n加油，为梦想~~（花样作死）~~努力，永远相信美好的事情即将发生！\n\n\n![](/img/2019/new-life-in-nj.jpeg)\n\n","tags":["碎碎念","旅行"],"categories":["人文"]},{"title":"TypeDoc插件开发小记","url":"/tech/how-to-create-plugin-for-typedoc.html","content":"\n### 关于TypeDoc是个什么鬼及其使用，可以阅读之前那篇文章\n\n[typedoc使用笔记](https://blog.tangkunyin.com/tech/typedoc-notes-1544152560.html)\n\n## 以下记录TOC二级菜单插件的开发\n\n先明确你自己的需求，你要做什么？现有的插件有没有能满足你的，如果有类似的，改改是否能用？如果毛都没有，那就从头写吧！\n\n造轮子有一定代价，官网如果没有良好的教程指导，那将会很令人神伤。而TypeDoc就是这样，至少我谷歌了好久，没找到类似教程的东西，索性一把梭的去看了好多插件的源码实现。还好明白套路...\n\n插件的作用无外乎是对原有的系统做了些许扩展。其原理在于某个时刻做某些拦截，然后构造必要的数据，然后再根据主题模板进行文件输出渲染。比如我们要改造TOC模块，使其支持二级栏目：\n\n### 1. GitHub找到TypeDoc源码，找到TOC模块所在\n\n[TocPlugin.ts](https://github.com/TypeStrong/typedoc/blob/master/src/lib/output/plugins/TocPlugin.ts)\n\n```\n\ninitialize() {\n    this.listenTo(this.owner, {\n        [PageEvent.BEGIN]: this.onRendererBeginPage\n    });\n}\n\nprivate onRendererBeginPage(page: PageEvent) {        \n    // 以上省略.... 可以看到这里，右边原有的TOC目录树就是从这里生成数据。而我们要改的可能也在这里\n    TocPlugin.buildToc(model, trail, page.toc, tocRestriction);\n}\n\n```\n\n### 2. 研究其他插件的入口文件index.js，我们可以发现\n\n所有插件都有类似的注册方法，即：你的插件名称，功能需要挂接到文档系统。当开始生成数据时，收到事件后开始构造需要的数据结构\n\n```\n\nconst P = require('./plugin');\n\nmodule.exports = function(PluginHost) {\n\tconst app = PluginHost.owner;\n\t\n\t// 如果已经注册过了，就别再重复注册\n\tif (app.converter.hasComponent(P.PLUGIN_NAME)) {\n\t\treturn;\n\t}\n\tif (app.renderer.hasComponent(P.PLUGIN_NAME)) {\n\t\treturn;\n\t}\n\n  // 此处声明插件名称\n\tapp.options.addDeclaration({ name: P.PLUGIN_NAME, short: P.PLUGIN_SHORT_NAME });\n\n  // 监听数据变化\n\tapp.converter.addComponent(P.PLUGIN_NAME, P.TocGroupPlugin);\n\n  // 监听页面渲染\n\tapp.renderer.addComponent(P.PLUGIN_NAME, P.TocGroupPlugin);\n};\n\n```\n\n### 3. 做必要的监听及数据模型构造\n\n研究TOC主题模板可以看到下图所示，其实最终读的就是toc这个变量里的children。而要改造的就是把标签内容再包一层，塞到这个变量里。弄成二维数组即可。\n\n![](/img/2018/15458121120623.jpg)\n\n\n需要注意的是，**一定要在`initialize`方法里正确的监听事件。否则拿不到你要的值**。正确监听的前提还必须是在`index.js`里正确注册。\n\n比如要处理`PageEvent`事件，就要监听`rendered`类型；处理`Converter`事件，就要监听`converter`类型。\n\n#### 获取文档中指定注解名称和内容\n\n```javascript\n\n// 1. initialize里监听： [Converter.EVENT_RESOLVE_BEGIN]: this.onBeginResolve,\n// 2. onBeginResolve回调中拿到Context，根据需求取或存数据\nconst groupedData = [];\nconst deprecatedData = new Set();\nconst mapedTocData = {};\nconst reflections = context.project.reflections;\nfor (const key in reflections) {\n    const ref = reflections[key];\n    const comment = ref.comment;\n    const homePath = `modules/_index_.${context.project.name.replace(/\\-/g, '')}.html`;\n\n    if (!comment || !comment.tags) continue;\n\n    for (const tag of comment.tags) {\n    // add deprecated item names\n    if (DEPRECATED_REGEXP.test(`@${tag.tagName}`)) deprecatedData.add(ref.name);\n    // add special tags\n    if (this.regexp.test(`@${tag.tagName}`)) {\n        groupedData.push(ref.name);\n        const groupKey = tag.text.split(/\\r\\n?|\\n/)[0];\n        if (!mapedTocData[groupKey]) mapedTocData[groupKey] = [];\n            mapedTocData[groupKey].push(ref.name);\n\t\t\t\t break;\n        }\n    }\n}\n\n// 以上构造的数据需要存到Context中，试过插件的成员变量，但是在其他事件回调中拿不到成员变量的值，事件关系没有深扒....\ncontext.project[PLUGIN_NAME] = { groupedData, deprecatedData, mapedTocData, homePath };\n\n```\n\n#### 构造我们所需要的数据\n\n请直接参考这里代码：[buildGroupTocContent](https://github.com/tangkunyin/typedoc-plugin-toc-group/blob/master/plugin.ts)\n\n\n### 4. 测试功能\n\n将插件目录下的文件组织好，配置编译命令。然后拷贝到`node_modules`下，执行`typedoc`构建时，将会自动加载插件，无需手动配置：\n\n> Loaded plugin xxx/node_modules/typedoc-plugin-toc-group\n\n如果控制台能打印类似的这条命令，那恭喜，你的新插件已经成功加载了。然后剩下的就是反复调试。直到实现你要的功能即可。\n\n\n### 5. 定制主题\n\n默认情况下，数据结构有了，页渲染出你要的结果了。但是可能长相不太好看。这时你就要定制一下默认的主题了。思路就是猜测你的功能所在的文件，然后去改造他。比如上面截图那个。\n\n改完了之后，你可以选择提交到npm，也可以放到自己项目中，用路径的方式去引用。\n\n### 6. 总结一下\n\n1. 明确需求，猜测与你功能相关的代码在哪里，去看源码；\n2. 研究其他插件或主题的目录结构，搭建自己的插件或主题目录结构；\n3. 入口文件注册事件，监听事件。拿到注解上的内容；\n4. 当页面开始渲染时，根据注解去解析、拼凑你要的数据结构；\n5. 将原来的数据结构从内部改掉（注意别改的太离谱否则加载会崩溃）；\n6. 数据没问题后，定制主题。改成你喜欢的样子；\n\n就写到这里，有不明白了。可以文章后留言，或者直接去看我写的这个主题。\n\n\n","tags":["typescript"],"categories":["科技"]},{"title":"浅谈Js模块化","url":"/tech/javascript-module-notes.html","content":"\n关于JS模块化的问题，一直被忽视，今天重来拿出来谈谈：`CommonJS`，`AMD`，`UMD`，以及`Harmony`等...\n\n> 没有模块化之前的操作：**script标签引入js文件，相互罗列，但是被依赖的放在前面，否则使用就会报错**。命名空间是由单一的全局对象来描述的，如`JQuery`的`$`。\n\n\n#### CommonJS\n\n主要用于NodeJS后端，采用同步的方式加载文件，它有四个重要的环境变量为模块化的实现提供支持：module、exports、require、global。实际使用时，用module.exports定义当前模块对外输出的接口（不推荐直接用exports），用require加载模块。\n\n特点：\n\n1. 模块可以多次加载，但是只会在第一次加载时运行一次，然后运行结果就被缓存了，以后再加载，就直接读取缓存结果。要想让模块再次运行，必须清除缓存。\n2. 模块加载会阻塞接下来代码的执行，需要等到模块加载完成才能继续执行——同步加载。\n\n\n#### AMD\n\n在服务端，模块文件都存在本地磁盘，读取非常快，所以这样做不会有问题。但是在浏览器端，限于网络原因，**CommonJS不适合浏览器端模块加载，更合理的方案是使用异步加载**，即：**ADM：异步模块定义，Asynchronous Module Definition**。\n\nAMD规范采用异步方式加载模块，模块的加载不影响它后面语句的运行。所有依赖这个模块的语句，都定义在一个回调函数中，等到加载完成之后，这个回调函数才会运行。\n\n一点优点：适合在浏览器环境中异步加载模块、并行加载多个模块；\n一点缺点：不能按需加载、开发成本大。\n\n#### CMD\n\nCMD是在AMD基础上改进的一种规范，和AMD不同在于对依赖模块的执行时机处理不同，CMD是就近依赖，而AMD是前置依赖。此规范其实是在sea.js推广过程中产生的。\n\n```javascript\n\n/** AMD写法 **/\ndefine([\"a\", \"b\", \"c\", \"d\", \"e\", \"f\"], function(a, b, c, d, e, f) { \n     // 等于在最前面声明并初始化了要用到的所有模块\n    a.doSomething();\n    if (false) {\n        // 即便没用到某个模块 b，但 b 还是提前执行了\n        b.doSomething()\n    } \n});\n\n/** CMD写法 **/\ndefine(function(require, exports, module) {\n    var a = require('./a'); //在需要时申明，很明显CMD可以做到按需加载\n    a.doSomething();\n    if (false) {\n        var b = require('./b');\n        b.doSomething();\n    }\n});\n\n```\n\n#### UMD\n\n**通用模块定义（UMD，Universal Module Definition）**。兼容AMD和commonJS规范的同时，还兼容全局引用的方式。可运行在浏览器或服务器环境。\n\n无导入导出规范，实现原理如下：\n\n1. 先判断是否支持Node.js模块格式（exports是否存在），存在则使用Node.js模块格式。\n2. 再判断是否支持AMD（define是否存在），存在则使用AMD方式加载模块。\n3. 前两个都不存在，则将模块公开到全局（window或global）。\n\n```javascript\n\n(function (root, factory) {\n    if (typeof define === 'function' && define.amd) {\n        //AMD\n        define(['jquery'], factory);\n    } else if (typeof exports === 'object') {\n        //Node, CommonJS之类的\n        module.exports = factory(require('jquery'));\n    } else {\n        //浏览器全局变量(root 即 window)\n        root.returnExports = factory(root.jQuery);\n    }\n}(this, function ($) {\n    //方法\n    function myFunc(){};\n    //暴露公共方法\n    return myFunc;\n}));\n\n```\n\n#### ES6 Module\n\n旨在成为浏览器和服务器通用的模块解决方案。\n\n其模块功能主要由两个命令构成：export和import。export命令用于规定模块的对外接口，import命令用于输入其他模块提供的功能。import命令会被 JavaScript 引擎静态分析，在编译时就引入模块代码，而不是在代码运行时加载，所以无法实现条件加载。也正因为这个，使得静态分析成为可能。\n\nES6模块是动态引用，并且不会缓存值，模块里面的变量绑定其所在的模块。\n\n特点：\n\n1. 按需加载（编译时加载）\n2. import和export命令只能在模块的顶层，不能在代码块之中（如：if语句中）,import()语句可以在代码块中实现异步动态按需动态加载\n\n语法：\n\n1. 导入：import {模块名A，模块名B...} from '模块路径'\n2. 导出：export和export default\n3. import('模块路径').then()方法\n\n> 注意：export只支持对象形式导出，不支持值的导出，export default命令用于指定模块的默认输出，只支持值导出，但是只能指定一个，本质上它就是输出一个叫做default的变量或方法。\n\n规范：\n\n```javascript\n\n/*错误的写法*/\n// 写法一\nexport 1;\n\n// 写法二\nvar m = 1;\nexport m;\n\n// 写法三\nif (x === 2) {\n  import MyModual from './myModual';\n}\n\n/*正确的三种写法*/\n// 写法一\nexport var m = 1;\n\n// 写法二\nvar m = 1;\nexport {m};\n\n// 写法三\nvar n = 1;\nexport {n as m};\n\n// 写法四\nvar n = 1;\nexport default n;\n\n// 写法五\nif (true) {\n    import('./myModule.js')\n    .then(({export1, export2}) => {\n      // ...·\n    });\n}\n\n// 写法六\nPromise.all([\n  import('./module1.js'),\n  import('./module2.js'),\n  import('./module3.js'),\n])\n.then(([module1, module2, module3]) => {\n   ···\n});\n\n```\n\n\n\n#### System\n\nsystemjs是模块加载器，可以导入任何流行格式的模块（CommonJS、UMD、AMD、ES6）。它是工作在ES6模块加载polyfill 之上，它能够很好的处理和检测所使用的格式。 systemjs 也能使用插件转换es6（ 用 Babel 或者 Traceur）或者转换TypeScript 和 CoffeeScript代码。你只需要在导入你的模块之前使用 System.config({ ... }) 进行系统配置。\n\n[Dynamic ES module loader](https://github.com/systemjs/systemjs)\n\n\n\n\n#### Harmony\n\n未来的模块，目前仍处于建设性阶段。\n\n支持基于远程来源的模块，如：\n\n```javascript\n\nmodule cakeFactory from \"http://addyosmani.com/factory/cakes.js\";\ncakeFactory.oven.makeCupcake( \"sprinkles\" );\ncakeFactory.oven.makeMuffin( \"large\" );\n\n```\n\n\n#### 相关资料：\n\n[https://segmentfault.com/a/1190000012419990](https://segmentfault.com/a/1190000012419990)\n\n[http://justineo.github.io/singles/writing-modular-js/](http://justineo.github.io/singles/writing-modular-js/)\n\n[https://juejin.im/post/5b4420e7f265da0f4b7a7b27#comment](https://juejin.im/post/5b4420e7f265da0f4b7a7b27#comment)\n\n[https://juejin.im/post/5aaa37c8f265da23945f365c](https://juejin.im/post/5aaa37c8f265da23945f365c)\n\n[http://wiki.jikexueyuan.com/project/javascript-design-patterns/es-harmony.html](http://wiki.jikexueyuan.com/project/javascript-design-patterns/es-harmony.html)\n\n\n\n\n\n","tags":["javascript"],"categories":["科技"]},{"title":"Npx使用","url":"/tech/what-is-the-npx.html","content":"\n`npx`是`npm v5.2.0`引入的一条命令，引入这个命令的目的是为了提升开发者使用包内提供的命令行工具的体验。\n\n\n举例：使用**create-react-app**创建一个react项目。\n\n老方法：\n```\nnpm install -g create-react-app\ncreate-react-app my-app\n```\n\nnpx方式：\n```\nnpx create-react-app my-app\n```\n\n这条命令会临时安装 create-react-app 包，命令完成后create-react-app 会删掉，不会出现在 global 中。下次再执行，还是会重新临时安装。\n\n也就是说 npx 会自动查找当前依赖包中的可执行文件，如果找不到，就会去 PATH 里找。如果依然找不到，就会帮你安装！\n\nnpx 甚至支持运行远程仓库的可执行文件：\n```\nnpx github:piuccio/cowsay hello\n```\n\n主要特点：\n\n1. 临时安装可执行依赖包，不用全局安装，不用担心长期的污染。\n2. 可以执行依赖包中的命令，安装完成自动运行。\n3. 自动加载node_modules中依赖包，不用指定$PATH。\n4. 可以指定node版本、命令的版本，解决了不同项目使用不同版本的命令的问题。\n\n\n","tags":["码常规"],"categories":["科技"]},{"title":"Typedoc使用笔记","url":"/tech/typedoc-notes.html","content":"\n**TypeDoc 是一款支持 TypeScript 的文档生成工具。**\n\n安装、使用方便。最后生成的是静态的 HTML 文件，界面简洁。\n\n提供多个可选的配置，并且可以按照自己的需求自定义界面样式。\n\n源码地址：[TypeDoc](https://github.com/TypeStrong/typedoc)\n\n文档地址：[TypeDoc Documentation](https://typedoc.org/api/index.html)\n\n![](/img/2018/15445225439852.jpg)\n\n\n### 优雅的使用方式\n\n```javascript\n\n// 1. 配置到package.json中，其中使用npx命令，无需单独安装typedoc库\n// 2. transform.js里可以将目标文档的特殊关键字替换。做一些前置处理\n\n\"scripts\": {\n    \"typingsdoc\": \"node typings/transform.js && npx typedoc --out ./typings/doc  ./typings  --module umd\"\n},\n\n```\n\n\n### 两个好用的插件\n\n[typedoc-plugin-single-line-tags](https://github.com/christopherthielen/typedoc-plugin-single-line-tags)\n\n以上插件可以用一个注解，将描述展示为一行。而非多行，比如一个私有类，可以增加一个@private，然后增加一段说明\n\n\n[typedoc-plugin-external-module-name](https://github.com/christopherthielen/typedoc-plugin-external-module-name)\n\n当有多个模块，分为不同文件时，可以用上面的插件将模块区分出来。做类似的二级栏目。\n\n\n### 关于同一Module文档的二级分类\n\n1. 使用上面的插件，按文件区分；\n2. 使用这个插件搞定：[typedoc-plugin-toc-group](https://github.com/tangkunyin/typedoc-plugin-toc-group)\n\n\n> 至于插件的开发，请移步这篇文章：\n\n\n[TypeDoc插件开发小记](https://blog.tangkunyin.com/tech/how-to-create-plugin-for-typedoc-1545808023.html)\n\n\n","tags":["码常规","typescript"],"categories":["科技"]},{"title":"Reading-or-Not","url":"/huma/reading-or-not.html","content":"\n![reading_or_not](/img/2018/reading_or_not.jpg)\n\n\n\nRecently this comic picture often come to my mind. Reality is always oppressive. I know I should read more books in order to see more beautiful world.\n","tags":["读书"],"categories":["人文"]},{"title":"JS和TS混编","url":"/tech/mixed-coding-between-js-and-ts.html","content":"\n以在react-native中二者混编为例，emm...\n\n","tags":["javascript","typescript"],"categories":["科技"]},{"title":"Flutter和Rax初探","url":"/tech/flutter-and-rax-hello.html","content":"\n## Flutter篇\n\n### 环境安装（macOS）\n\n#### 参考`Flutter`中文网的教程：[https://flutterchina.club/setup-macos/](https://flutterchina.club/setup-macos/)\n\n以上流程基本上是一把梭的就装好了，唯一需要注意的是**PUB_HOSTED_URL**和**FLUTTER_STORAGE_BASE_URL**这俩得写进环境变量配置里，如下：\n\n```\n# 1，我直接加到了系统环境变量中，需要加到自己家目录下同理\nvim /etc/profile\n\n# 2，复制以下配置\n# Flutter SDK https://flutterchina.club/setup-macos/\nPUB_HOSTED_URL=https://pub.flutter-io.cn\nFLUTTER_STORAGE_BASE_URL=https://storage.flutter-io.cn\nPATH=~/dev-lib/flutter/bin:$PATH\n\nexport PATH PUB_HOSTED_URL FLUTTER_STORAGE_BASE_URL\n\n# 3，使环境变量生效\n\nsource /etc/profile\n\n```\n\n#### 校验其他依赖\n\n执行：`flutter doctor`，该命令检查您的环境并在终端窗口中显示报告，所以缺什么，直接复制命名继续安装即可，直到我这样就行了：\n\n![](/img/2018/15311311861503.jpg)\n\n### 开始撸代码，首先配置IDE（此处以VS Code为例）\n\n#### 配置方式如下\n\n[Visual Studio Code (VS Code) Dart安装](https://flutterchina.club/get-started/editor/#vscode)\n\n\n#### 启动模拟器\n\n![](/img/2018/15311314047697.jpg)\n\n这里用iOS模拟器演示，执行：`flutter emulators --launch apple_ios_simulator`。然后模拟器就被正常启动\n\n#### 打开VS Code并创建Demo工程，按F5后\n\n![Simulator Screen Shot - iPhone 8 Plus - 2018-07-09 at 18.20.54](/img/2018/Simulator%20Screen%20Shot%20-%20iPhone%208%20Plus%20-%202018-07-09%20at%2018.20.54.png)\n\n### 至此，`Flutter`的`Hello-World`工程就跑起来了，之后需要做的就是去学习语法开始撸代码\n\n\n## Rax篇\n\n> 先来区分一下概念：Weex和Rax\n> > 前者是一个容器（运行时环境），后者是一个跨容器的渲染引擎。即：Rax可以跑在Weex里，但Weex不能跑在Rax中。\n> > 两者是相互独立的。Weex可以简单理解为：`Vue-Native`。拿知乎段友的话概括就是：“看了一下好像是淘宝写 react-web 那几个人弄的，我猜他们是要用 weex 但是又喜欢 react 那套思想，所以整了个类 react 的东西，可以直接在 weex 里面渲染，也就是说可以用类似 react-native 的方式来写 weex 了”\n\n具体也可以看看这里：[Rax 系列教程（native 扫盲）](http://taobaofed.org/blog/2018/02/06/rax-native-guide/)\n\n### 安装\n\n[Rax快速开始](https://alibaba.github.io/rax/guide/getting-started)\n\n```\n# 1. 安装命令行\nnpm install -g rax-cli\n\n# 2. 初始化项目\nrax init hello-rax\n\n# 3. 启动 \nnpm run start\n```\n\n### 跑起来\n\n#### Web端\n\n通过控制台生成的二维码，直接访问\n\n#### Native端\n\n1. 先安装Weex: `npm install -g weex-toolkit`\n\n再在Rax目录中创建Weex环境：\n\n![](/img/2018/15312064317112.jpg)\n\n2. 通过**weex create**创建的工程，没有iOS和Android工程模板，此时需要安装**weex**应用模板\n\n```\n// iOS (需要手动执行pod install)\nweex platform add ios\n\n// 安卓\nweex platform add android\n```\n\n3. 打开`WeexDemo.xcworkspace`，修改`BUNDLE_URL`并运行`playground`\n\n![](/img/2018/15312115498098.jpg)\n\n4. 启动模拟器，就可以看到`Rax`跑起来了\n\n![](/img/2018/15312116337280.jpg)\n\n\n\n## 总结\n\n1. 大腿方：Flutter抱Google，Rax抱Alibaba;\n2. 易用性：Flutter完爆Rax。Rax创建后只有编码环境，运行环境还得再装Weex，而Weex又是一个神奇的东西，对Native不熟的，可能会比较捉急；\n3. 通用性：Flutter目前主要用来做移动端，Web端不行。Rax则通吃，包括Web；\n4. Weex和RN对比：[Weex和RN对比](https://zhuanlan.zhihu.com/p/21677103)\n\n","tags":["flutter","前端","跨端"],"categories":["科技"]},{"title":"跨端桌面应用解决方案与开发","url":"/tech/cross-platform-desktop.html","content":"\n### 方案\n\n#### Electron\n\n> 在客户端程序里面加入 webkit 做为引擎渲染存在本地 web 页面。使用这种解决方案典型的项目有 Atom, Github Desktop, Slack, visualstudio. 这些都是大公司的做出来的成果，目前看起来 Electron 是解决 GUI 跨平台很流行的方案，这得益于于 V8 的高性能，也和 nodejs 社区发展得如火如荼离不开关系。nodejs 几乎快变成了适用于任意地方万金油一样的编程语言。可是在客户端潜入一个 webkit 无论如何都会非常笨重，也难以做到轻量。你可能写一个简单的 hello world 弹窗最后打包的程序都需要 100M。 Electron 不适合轻量级的程序，也不是一个长期的 GUI 解决方案。它只适用于你只想做出一个凑合可用的跨平台应用。 Electron 应用更像是简单的把 HTML/CSS/JS 搬到一个不需要输入网址的浏览器里面。\n\n\n#### React Native Desktop\n\n> Qt 在不同的平台上面把 GUI 直接画出来。Qt 发展了这么多年，一直处于非常冷清的状态，也很少见着一些大型的客户端是用 Qt 做出来的。Qt 也非常庞大，并不比基于 webkit 的 Electron 轻量。C++ 的使用和学习成本都非常高，做界面一致性远远也不如 web。除非不得已，现在几乎不会用 Qt 做为跨平台 GUI 的解决方案。C++ 自身跨平台代价也非常高。\n\n#### Electrino\n\n> **Electron**的优化版，使用系统的浏览器引擎，大大降低了打包后应用的体积。然目前不支持Windows。有人相信总有一天会取代**Electron**，可惜遗憾的时该项目GitHub已经一年多没有更新了。。。\n\n#### Proton-Native\n\n> 用React的思路封装了**libui-node**，底层的能力就是**libui**，不过目前不太成熟，实现商业化项目比较费劲。\n\n\n#### React-Native\n\n> 是的，你没看错。[react-native-macos](https://github.com/ptmt/react-native-macos)和[react-native-windows](https://github.com/Microsoft/react-native-windows)这俩库扩展了**React-Naitve**，使得你可以开发macOS和Windows相对完美的Native应用，目前来讲就他合适了。\n\n\n### 资料\n\nhttp://www.leyafo.com/post/2017-07-18-cross-platform-gui-solution-2017/\nhttps://josephg.com/blog/electron-is-flash-for-the-desktop/\nhttps://github.com/atom/atom/issues/14199\nhttps://www.zhihu.com/question/267324734\n\n\n","tags":["前端","跨端"],"categories":["科技"]},{"title":"Typescript入坑篇1","url":"/tech/ts-study-part1.html","content":"\n![](/img/2018/15459066435251.jpg)\n\n\n## 以上是来自官方的中文定义（找了半天Logo，发现并没有...俩大写字母太难看）\n\n### 1. 前置工作\n\n在开始构建TS项目前，建议先把编码环境调整ok，即：**统一代码规范及结构，保证提交的是高质量的、同时尽量避免低级错误**，最起码看起来爽，让别人知道你不是一个随便的人...\n\n> 接下来，记录一下**prettier**、**eslint|tslint**、**husky**、**lint-staged**套装的使用。\n\n#### 依赖情况\n\n```javascript\n// .eslintrc.json内\n{\n\t\"extends\": [\n\t\t\"standard\",\n\t\t\"plugin:prettier/recommended\"\n\t],\n\t\"parserOptions\": {\n\t\t\"ecmaVersion\": 7,\n\t\t\"sourceType\": \"module\",\n\t\t\"ecmaFeatures\": {\n\t\t\t\"jsx\": true\n\t\t}\n\t},\n\t\"parser\": \"babel-eslint\",\n\t\"env\": {\n\t\t\"es6\": true,\n\t\t\"browser\": true,\n\t\t\"node\": true\n\t},\n\t\"plugins\": [\"react\", \"jsx-a11y\", \"import\"],\n\t\"rules\": {\n\t\t\"prettier/prettier\": \"error\",\n\t\t\"class-methods-use-this\": 0,\n\t\t\"import/no-named-as-default\": 0,\n\t\t\"react/jsx-filename-extension\": [\n\t\t\t\"error\",\n\t\t\t{\n\t\t\t\t\"extensions\": [\".js\", \".jsx\"]\n\t\t\t}\n\t\t]\n\t}\n}\n\n// .prettierrc内（注意这个文件没有后缀。据说是加后缀VSCode不认，本人偏爱JB全家桶，所以没试过...）\n{\n  \"printWidth\": 180,\n  \"tabWidth\": 4,\n  \"useTabs\": false,\n  \"semi\": true,\n  \"singleQuote\": true,\n  \"jsxSingleQuote\": false,\n  \"trailingComma\": \"all\",\n  \"bracketSpacing\": false,\n  \"jsxBracketSameLine\": true,\n  \"arrowParens\": \"always\"\n}\n\n// package.json内\n{\n    \"devDependencies\": {\n        \"typescript\": \"^3.2.2\",\n        \"typedoc\": \"^0.13.0\",\n        \"babel-eslint\": \"^10.0.1\",\n        \"eslint\": \"^5.11.1\",\n        \"eslint-config-prettier\": \"^3.3.0\",\n        \"eslint-config-standard\": \"^12.0.0\",\n        \"eslint-plugin-import\": \"^2.14.0\",\n        \"eslint-plugin-jsx-a11y\": \"^6.1.2\",\n        \"eslint-plugin-standard\": \"^4.0.0\",\n        \"eslint-plugin-react\": \"^7.12.0\",\n        \"eslint-plugin-node\": \"^8.0.0\",\n        \"eslint-plugin-prettier\": \"^3.0.1\",\n        \"eslint-plugin-promise\": \"^4.0.1\",\n        \"prettier\": \"^1.15.3\",\n        \"husky\": \"^1.3.1\",\n        \"lint-staged\": \"^8.1.0\"\n    },\n    \"husky\": {\n        \"hooks\": {\n            \"pre-commit\": \"lint-staged\"\n        }\n    },\n    \"lint-staged\": {\n        \"src/**/*.{jsx,txs,ts,js,json,css,md}\": [\n            \"prettier --write\",\n            \"eslint --fix\",\n            \"git add\"\n        ]\n    }\n}\n```\n\n以上环境配好后，可以试着在`src`下建一个`*.js`文件。随便写点东西，然后咱们提交代码，看看发生了啥~\n\n![](/img/2018/15460683493736.jpg)\n\n\n嗷嗷，如此犀利是不是。以上是针对ES的，来看下TS大法的~\n\n- 新增俩文件：**tslint.json**和**tsconfig.json**，前者是规范约束文件，后者是ts编译参数配置\n\n```javascript\n// tslint.json\n{\n    \"defaultSeverity\": \"error\",\n    \"extends\": [\n        \"tslint:recommended\",\n        \"tslint-config-prettier\"\n    ]\n}\n\n// tsconfig.json\n{\n  \"compilerOptions\": {\n    \"sourceMap\": true,\n    \"allowSyntheticDefaultImports\": true,\n    \"declaration\": false,\n    \"target\": \"es6\",\n    \"moduleResolution\": \"node\",\n    \"allowJs\": true,\n    \"module\": \"umd\",\n    \"outDir\": \"./dist\",\n    \"experimentalDecorators\": true\n  },\n  \"exclude\": [\n    \"node_modules\"\n  ]\n}\n\n// package.json\n{\n    \"tslint\": \"^5.12.0\",\n    \"tslint-config-prettier\": \"^1.17.0\"\n}\n\n// 其中scripts内需要配上tsc\n\"scripts\": {\n    \"build\": \"tsc\",\n    \"prepare\": \"npm run build\"\n}\n```\n\n关于这个架手架的源码，可以参考这里：[TypeScript](https://github.com/tangkunyin/hello-fe/tree/master/TypeScript)\n\n\n到现在为止，好像关于写TS的事情并没有记录。做了太多前置工作，内容放到[part2](https://blog.tangkunyin.com/tech/ts-study-part2-1546832521.html)吧...\n\n另外，叨叨一句，**EditorConfig**可以不用了（要了也是多余）\n\n> 参考资料：\n\n[使用ESLint+Prettier来统一前端代码风格](https://juejin.im/post/5b27a326e51d45588a7dac57)\n\n[专治代码洁癖系列](https://juejin.im/post/5a791d566fb9a0634853400e)\n\n","tags":["前端","typescript"],"categories":["科技"]},{"title":"致为知笔记们","url":"/huma/WizNote-Uninstall.html","content":"\n### 用了近三年，你们也不容易，哎...\n\n今天干了多半天的体力活，将**为知笔记**上的技术内容整理、删减各种折腾，最终留下并迁移了近40篇到HEXO。虽说不是什么精华，但那毕竟是记忆。\n\n2015年4月21日我们相遇，对比了**印象笔记**等XX类笔记后，看上了你。今天还是不得不分手...\n\n尤其是前阵子升级差点丢了数据，近乎懵逼的感觉让我下决心抛弃你。庆幸手没那么快。如果先卸载了，那只有哭了...\n\n也怪我没及时看到你的更新公告： [关于升级至新同步服务的公告](https://www.wiz.cn/syncserviceupgrade.html)\n\n嗯，往后，还是自己托管的好\n\n加油吧...\n\n![](/img/2018/15280301218237.jpg)\n\n\n","tags":["工具"],"categories":["人文"]},{"title":"Vue学习笔记","url":"/tech/vue-study-notes.html","content":"\n### 一，建立一个Vue工程：\n\n![](/img/2018/15280280857568.jpg)\n\n然后就完了....\n\n### 二，打开这个功能，命令行执行：npm run dev ，就可以看到正常的网页\n\n### 三，单文件组件的写法与用法：\n\n1. 新建一个vue文件，写好内容；\n2. 需要的地方引入，其中注意 @ 为 Vue自带的，表示src。如以下引用方式：\n![](/img/2018/15280281314771.jpg)\n\n3. 使用Less支持，package.json中添加：less和less-loader，然后文件夹：build->webpack-base-config.js中添加如下：\n```javascript\n{\n  test: /\\.less$/,\n  loader: 'style-loader!css-loader!less-loader'\n}\n```\n\n![](/img/2018/15280281796136.jpg)\n\n\n## 暂时玩儿到这里，有需要会继续折腾...\n\n代码： [Hello-FE](https://github.com/tangkunyin/Hello-FE)\n\n","tags":["javascript","vue"],"categories":["科技"]},{"title":"React16的一些问题及对策","url":"/tech/react16-usage.html","content":"\n### 1，如果render中的组件以属性的方式引用了当前类的函数，且在constructor中bind这个函数，会造成这个函数仅刷新一次，如：\n\n![](/img/2018/15280277890966.jpg)\n\n![](/img/2018/15280277972569.jpg)\n\n![](/img/2018/15280278031260.jpg)\n\n#### 解决方式：在Render中bind，在SCU中再拦截，控制实际Render次数\n\n![](/img/2018/15280278204992.jpg)\n\n##  原因是：暂时不知道！！！ \n\n捂脸.png\n捂脸.png\n捂脸.png\n\n\n","tags":["前端","javascript","react"],"categories":["科技"]},{"title":"ReactNative导航的解决方案","url":"/tech/react-navigation.html","content":"\n### 一、纯JS的解决方案：React Navigation\n\n易用、跨平台、良好的状态管理\n教程：\n\n> https://www.jianshu.com/p/2f575cc35780\n> https://www.jianshu.com/p/b877115fff1b\n\n概况，React Navigation分为三个部分：\n```\nStackNavigator：类似顶部导航条，用来跳转页面和传递参数；\nTabNavigator：类似底部标签，用来区分模块；\nDrawerNavigator：抽屉，类似从APP侧滑出一个页面\n```\n\n#### 1、注意事项：\n\n> iOS和Android平台的tabs默认行为不一致，表现在iOS正常，安卓的tab在顶部且处于可滑动状态，一统江山方法如下：\n\n```javascript\nconst Navigation = TabNavigator(\n    {\n        tab1: { screen: screen1 },\n        tab2: { screen: screen2 },\n    },\n    // customize app tab bars\n    {\n        tabBarPosition: 'bottom',\n        tabBarComponent: TabBarBottom, // 安卓默认是顶部，不设置该项可能导致tabIcon位置错误\n        swipeEnabled: false, // 安卓默认可滑动\n        lazy: true,\n        initialRouteName: 'Offline',\n        tabBarOptions: {\n            indicatorStyle: {\n                height: 0, // android 中TabBar下面会显示一条线，高度设为 0 后就不显示线了\n            },\n            style: {\n                height: 49,\n                backgroundColor: 'white'\n          },\n            labelStyle: {\n                marginBottom: 3\n            },\n            iconStyle: {\n                height: 24,\n                width: 24,\n                margin: 0\n            },\n            showIcon: true, // 是否显示图标，安卓默认关闭\n            // label和icon的前景色 活跃状态下（选中）\n            activeTintColor: '#4ECBFC',\n            // label和icon的前景色 不活跃状态下(未选中)\n            inactiveTintColor: '#aaa',\n            // label和icon的背景色 活跃状态下\n            activeBackgroundColor: 'white',\n            // label和icon的背景色 不活跃状态下\n            inactiveBackgroundColor: 'white',\n            // 不透明度为按选项卡(iOS和Android < 5.0)\n            pressOpacity: 0.3,\n            scrollEnabled: false， // 是否启用可滚动的选项卡，安卓特有\n        }\n    }\n);\n```\n\n**安卓tabbar文字会下移，因为安卓比iOS多一个属性，就是iconStyle，通过设置labelStyle和iconStyle两个样式，可以调整整理合理性。**\n\n#### 2、安卓导航栏文字默认居左调整\n自定义导航样式，重写：\n\n> headerTitleStyle\n\n#### 3、让安卓实现push动画\n\n```javascript\n// 先引入这个方法\nimport CardStackStyleInterpolator from 'react-navigation/src/views/CardStackStyleInterpolator';\n​\n// 在StackNavigator配置headerMode的地方，使用transitionConfig添加\n{\n    headerMode: 'screen',\n    transitionConfig:()=>({\n        screenInterpolator:CardStackStyleInterpolator.forHorizontal,\n    })\n}\n\n```\n\n### 二、iOS平台专用的：NavigatorIOS\n\n提供UINavigationViewController类的方法。其中Navigator已经被正式废弃！（于RN44被抛弃）\n\n> 替代方案：react-native-deprecated-custom-components\n\n### 三、Native外观和体验的跨端方案：native-navigation, react-native-navigation.\n\n其中前者有AirBnb团队开发，1.x前处于不稳定版本。不建议投入正式用途。\n后者由WiX团队提供。目前功能已经相对完整，功能完全。必须在RN 0.43以后才可以用。\n如果是混合开发，比如RN模块只作为一个TAB嵌入，那么可以考虑这种方案。\n\n> 具体资料如下：https://wix.github.io/react-native-navigation/#/\n\n","tags":["前端","react-native"],"categories":["科技"]},{"title":"pm2控制多个ReactNative控制台","url":"/tech/pm2-rn-combine.html","content":"\n### 一、pm2小试牛刀\n\n#### 1、安装PM2：[pm2](https://github.com/Unitech/pm2)\n> npm install pm2 -g\n\n#### 2、常用命令：\n> pm2 ls\n![](/img/2018/15280267906540.jpg)\n\n> pm2 monit\n\n![](/img/2018/15280268329791.jpg)\n\n#### 3、 常用的服务启动命令：\n```\n// 从某个文件作为服务入口启动\npm2 start app.js\n​\n// 启动所有定义在packge.json中的服务\npm2 start package.json\n​\n// 启动一个Node应用程序\npm2 start npm -- start\n```\n\n### 二、ReactNative默认端口修改\n\n> 默人情况下，ReactNative的PackageManager端口是8081。\n\n#### 1、临时修改端口（这个命令是2017年8月1号以后增加的功能）\n> // 监听9999\n> react-native start --port 9999\n\n#### 2、永久修改\n\nplanA：\n> 手动修改所有涉及端口的文件，具体文件可谷歌\n\nplanB：\n\n> https://github.com/ktonon/react-native-port-patcher\n> script中加postinstall，devDependences加\n\n```\n\"postinstall\": \"react-native-port-patcher --new-port 9092\"\n\"react-native-port-patcher\": \"^1.0.2\"\n```\n\n安装以后，执行： yarn install | npm install \n打开Xcode后，重新编译，就可使用新的端口\n\n### 三、pm2控制多个ReactNative服务\n\n#### 启动一个名为xxName的进程，可多个一起。其中`start`为`scripts`中定义的命令\n\n```\npm2 start npm --name xxName -- run start\n```\n​\n#### 这种方式会启动一个名为npm的进程，如果不区别名称，则另外一个无法启动\n\n```\npm2 start npm -- start\n```\n\n\n![](/img/2018/15280271298874.jpg)\n\n\n","tags":["码常规","javascript","react-native"],"categories":["科技"]},{"title":"创建ReactNative项目的优雅方式","url":"/tech/create-rn-in-better-way.html","content":"\n### 先说不优雅的方式，即：react-native init xxx\n\n可以在init时加上模板参数，即：\n\n> react-native init xxx --template youui  // 这个意思就是生成youui开发样板（脚手架）\n\n这种方式会生成XCode及Android Studio工程。通过XCode等工具可以直接运行模拟器或真机。\n\n### 优雅的方式\n\n#### 1、官方推荐的QuickStart，即CRNA：create-react-native-app\n![](/img/2018/15280262453183.jpg)\n\n**CRNA方式会生成一个带Expo的环境，但不会有XCode和Android Studio工程。也不会有各种目录配置。通过Expo客户扫描控制台二维码启动应用。\n**\n\n#### 2、Ignite生成项目\n\nIGNITE的官方地址：https://github.com/infinitered/ignite\n\n> IGNITE是一个React Native的脚手架生成器（了解ROR的可以理解为rails命令），通过一个命令就可以生成一个结构完整的、可工作的空白react native项目，后续的开发就是向这个项目添砖加瓦，这比从头构建一个RN项目节省很多时间。而且IGNITE默认集成的很多库也都是不二之选，包含了前人的经验。\n\n**ignite new 之后会生成标准的开发结构。包括Reactotron配置等。结构比较重，版本也不见得是最新的！**\n\n#### 3、Expo方式\n\n一、概念\n普及英文读法： ['ɛkspoʊ]，本身是展览会的意思。\n\n来看官方的解释：https://docs.expo.io/versions/latest/index.html\n\n> Expo is a set of tools, libraries and services which let you build native iOS and Android apps by writing JavaScript\n\n```\nExpo是一组工具、库和服务，可以通过编写JavaScript来构建本地的ios和Android应用程序\nExpo Apps是包含了Expo SDK的react native Apps,SDK是一个native-and-js的库，它包提供对设备系统的访问功能，像照相机、联系人、本地存储和其他硬件）。这意味着你不需要使用Xcode或Android的环境，或写任何代码也使得你的pure-JS项目非常便携，因为它可以运行在任何自然环境包含Expo SDK。\nExpo还提供UI组件来处理各种应用程序，几乎所有应用程序都将被覆盖，但它不会突破react native Core的核心代码，例如图标、模糊视图，等等。\n最后，Expo SDK提供了访问服务，这些服务虽然很难管理，但几乎每个应用程序都需要它。其中最受欢迎的是：Expo可以为您管理您的资产，它可以为您处理推送通知，并且它可以构建准备部署到应用程序商店的本地二进制文件\n```\n\nFaceBook的解释如下：\n\nhttps://facebook.github.io/react-native/docs/more-resources.html Expo is a development environment plus application that focuses on letting you build React Native apps in the Expo development environment, without ever touching Xcode or Android Studio. If you wish React Native was even more JavaScripty and webby, check out Expo.\n\n![](/img/2018/15280264067172.jpg)\n\n\n二、和Ignite等模板的区别？\n\nIgnite是一个脚手架生成工具，提供便捷的模板。区别于Expo，它没有类似环境、服务的概念。某种意义上跟CRNA是一种东西。而后者主要是提供另一种RN开发环境，比如Windows下开发流程等。Ignite可以作为模板扩展，加入到Expo工程里\n\n\n![](/img/2018/15280264415058.jpg)\n\n### 关于打造自己的脚手架\n\nhttps://zhuanlan.zhihu.com/p/32190298\n\n### 另外有一篇关于：React Native App应用架构设计\n\n绝对是干货：[React Native App应用架构设计](https://zhuanlan.zhihu.com/p/30617441)\n\n\n","tags":["前端","javascript","react-native"],"categories":["科技"]},{"title":"Npm安装完后的回调处理","url":"/tech/npm-script-postinstall.html","content":"\n### 比如在ReactNative中，安装完依赖之后，需要改端口、删掉某些文件....\n\n> 多个操作不能在package.json中定义数组，但可以重新定义一个脚本，在脚本中定义操作集合：\n\n![](/img/2018/15280257721155.jpg)\n\nshell中这么写就行\n\n```javascript\n#!/bin/bash\n\necho 'Now run custom commands after all package is installed.'\n\necho 'modify react-native package-manager default port'\nreact-native-port-patcher --new-port 9090\n\necho 'fix `Font Awesome` could not be found within the package etc.'\nrm ./node_modules/react-native/local-cli/core/__fixtures__/files/package.json\n```\n\n\n","tags":["码常规","javascript"],"categories":["科技"]},{"title":"WebStorm语法高亮问题","url":"/tech/highlight-webstorm.html","content":"\n## 一定程度上解决React-Native开发过程中，WebStorm语法高亮的问题\n\n###  Cannot resolve symbol ‘Component’ & Cannot resolve symbol‘PropTypes’\n\n```\n1.解决 Cannot resolve symbol 'Component' \n\n  安装依赖：npm install @types/react --save\n  调用方法：import React, { Component } from 'react'\n\n2.解决 Cannot resolve symbol 'PropTypes'\n\n  安装依赖：npm install prop-types --save\n  调用方法：import PropTypes from 'prop-types'\n```\n\nhttps://www.npmjs.com/package/@types/react-native\n\n> npm install --save @types/react-native\n\n","tags":["码常规"],"categories":["科技"]},{"title":"如果用Redux不爽的话那就试试MobX吧","url":"/tech/mobx-vs-redux.html","content":"\n## Redux之父的建议：unhappy with redux? try mobx...\n\n### 为什么不用Redux了，三个哲学问题（未解之谜）？\n\n1. Action太多导致不记得Action的命名到底是什么？随便一个需求就要改动多个文件，一个小心写错字符，就够你查半天原因。及时专门写个管理工具，管理起来也非常痛苦；\n2. Action的流向到底是什么？\n3. 经种种处理和反复传递，写reducer时，不打个logo真的不知道拿到什么数据结构\n\n\n> 中文文档：https://suprise.github.io/mobx-cn/\n\n![](/img/2018/15280251601947.jpg)\n\n\n\n","tags":["javascript"],"categories":["科技"]},{"title":"MobX思想的实现原理","url":"/tech/mobx-core-study.html","content":"\n### Mobx 最关键的函数在于 autoRun，举个例子，它可以达到这样的效果：\n\n```javascript\nconst obj = observable({\n    a: 1,\n    b: 2\n})\n\nautoRun(() => {\n    console.log(obj.a)\n})\n\nobj.b = 3 // 什么都没有发生\nobj.a = 2 // observe 函数的回调触发了，控制台输出：2\n```\n\n我们发现这个函数非常智能，用到了什么属性，就会和这个属性挂上钩，从此一旦这个属性发生了改变，就会触发回调，通知你可以拿到新值了。没有用到的属性，无论你怎么修改，它都不会触发回调，这就是神奇的地方。\n\n### autoRun 的用途\n\n使用 autoRun 实现 mobx-react 非常简单，核心思想是将组件外面包上 autoRun，这样代码中用到的所有属性都会像上面 Demo 一样，与当前组件绑定，一旦任何值发生了修改，就直接 forceUpdate，而且精确命中，效率最高。\n\n### 依赖收集\n\nautoRun 的专业名词叫做依赖收集，也就是通过自然的使用，来收集依赖，当变量改变时，根据收集的依赖来判断是否需要更新。\n\n### 实现步骤拆解\n\n为了兼容，Mobx 使用了 Object.defineProperty 拦截 getter 和 setter，但是无法拦截未定义的变量，为了方便，我们使用 proxy 来讲解，而且可以监听未定义的变量哦。\n\n#### 步骤一 存储结构\n\n众所周知，事件监听是需要预先存储的，autoRun 也一样，为了知道当变量修改后，哪些方法应该被触发，我们需要一个存储结构。\n\n首先，我们需要存储所有的代理对象，让我们无论拿到原始对象，还是代理对象，都能快速的找出是否有对应的代理对象存在，这个功能用在判断代理是否存在，是否合法，以及同一个对象不会生成两个代理。\n\n代码如下：\n\n```javascript\nconst proxies = new WeakMap()\n\nfunction isObservable<T extends object>(obj: T) {\n    return (proxies.get(obj) === obj)\n}\n```\n\n重点来了，第二个要存储的是最重要的部分，也就是所有监听！当任何对象被改变的时候，我们需要知道它每一个 key 对应着哪些监听（这些监听由 autoRun 注册），也就是，最终会存在多个对象，每个对象的每个 key 都可能与多个 autoRun 绑定，这样在更新某个 key 时，直接触发与其绑定的所有 autoRun 即可。\n\n代码如下：\n\n> const observers = new WeakMap<object, Map<PropertyKey, Set<Observer>>>()\n\n第三个存储结构就是待观察队列，为了使同一个调用栈多次赋值仅执行一次 autoRun，所有待执行的都会放在这个队列中，在下一时刻统一执行队列并清空，执行的时候，当前所有 autoRun 都是在同一时刻触发的，所以让相同的 autoRun 不用触发多次即可实现性能优化。\n\n> const queuedObservers = new Set()\n\n代码如下：\n\n我们还要再存储两个全局变量，分别是是否在队列执行中，以及当前执行到的 autoRun。\n\n代码如下：\n```javascript\nlet queued = false\nlet currentObserver: Observer = null\n```\n\n\n#### 步骤二 将对象加工可观察\n\n这一步讲解的是 observable 做了哪些事，首先第一件就是，如果已经存在代理对象了，就直接返回。\n\n代码如下：\n```javascript\nfunction observable<T extends object>(obj: T = {} as T): T {\n    return proxies.get(obj) || toObservable(obj)\n}\n```\n\n我们继续看 toObservable 函数，它做的事情是，实例化代理，并拦截 get set 等方法。\n\n我们先看拦截 get 的作用：先拿到当前要获取的值 result，如果这个值在代理中存在，优先返回代理对象，否则返回 result 本身（没有引用关系的基本类型）。\n\n上面的逻辑只是简单返回取值，并没有注册这一步，我们在 currentObserver 存在时才会给对象当前 key注册 autoRun，并且如果结果是对象，又不存在已有的代理，就调用自身 toObservable 再递归一遍，所以返回的对象一定是代理。\n\nregisterObserver 函数的作用是将 targetObj -> key -> autoRun 这个链路关系存到 observers 对象中，当对象修改的时候，可以直接找到对应 key 的 autoRun。\n\n那么 currentObserver 是什么时候赋值的呢？首先，并不是访问到 get 就要注册 registerObserver，必须在 autoRun 里面的才符合要求，所以执行 autoRun 的时候就会将当前回调函数赋值给 currentObserver，保证了在 autoRun 函数内部所有监听对象的 get 拦截器都能访问到 currentObserver。以此类推，其他 autoRun 函数回调函数内部变量 get 拦截器中，currentObserver 也是对应的回调函数。\n\n代码如下：\n```javascript\nconst dynamicObject = new Proxy(obj, {\n    // ...\n    get(target, key, receiver) {\n        const result = Reflect.get(target, key, receiver)\n\n        // 如果取的值是对象，优先取代理对象\n        const resultIsObject = typeof result === 'object' && result\n        const existProxy = resultIsObject && proxies.get(result)\n\n        // 将监听添加到这个 key 上\n        if (currentObserver) {\n            registerObserver(target, key)\n            if (resultIsObject) {\n                return existProxy || toObservable(result)\n            }\n        }\n\n        return existProxy || result\n    }),\n    // ...\n})\n```\n\nsetter 过程中，如果对象产生了变动，就会触发 queueObservers 函数执行回调函数，这些回调都在 getter 中定义好了，只需要把当前对象，以及修改的 key 传过去，直接触发对应对象，当前 key 所注册的 autoRun 即可。\n\n代码如下：\n```javascript\nconst dynamicObject = new Proxy(obj, {\n    // ...\n    set(target, key, value, receiver) {\n        // 如果改动了 length 属性，或者新值与旧值不同，触发可观察队列任务\n        if (key === 'length' || value !== Reflect.get(target, key, receiver)) {\n            queueObservers<T>(target, key)\n        }\n\n        // 如果新值是对象，优先取原始对象\n        if (typeof value === 'object' && value) {\n            value = value.$raw || value\n        }\n\n        return Reflect.set(target, key, value, receiver)\n    },\n    // ...\n})\n```\n\n没错，主要逻辑已经全部说完了，新对象之所以可以检测到，是因为 proxy 的 get 会触发，这要多谢 proxy 的强大。\n\n可能有人问 Object.defineProperty 为什么不行，原因很简单，因为这个函数只能设置某个 key 的 gettersetter~。\n\nsymbol proxy reflect 这三剑客能做的事还有很多很多，这仅仅是实现 Object.observe 而已，还有更强大的功能可以挖掘。\n\n> mobx 的 proxy 完整实现版本参考 https://github.com/nx-js/observer-util 项目。\n\n\n### 谈谈 Redux 与 Mobx 思想的适用场景\n\n> Redux 和 Mobx 都是当下比较火热的数据流模型，一个背靠函数式，似乎成为了开源界标配，一个基于面向对象，低调的前行。\n\n#### 函数式 vs 面向对象\n\n> 首先任何避开业务场景的技术选型都是耍流氓，我先耍一下流氓，首先函数式的优势，比如：\n\n1. 无副作用，可时间回溯，适合并发。\n2. 数据流变换处理很拿手，比如 rxjs。\n3. 对于复杂数据逻辑、科学计算维的开发和维护效率更高。\n\n当然，连原子都是由带正电的原子核，与带负电的电子组成的，几乎任何事务都没有绝对的好坏，面向对象也存在很多优势，比如：\n\n1. javascript 的鸭子类型，表明它基于对象，不适合完全函数式表达。\n2. 数学思维和数据处理适合用函数式，技术是为业务服务的，而业务模型适合用面向对象。\n3. 业务开发和做研究不同，逻辑严谨的函数式相当完美，但别指望每个程序员都愿意消耗大量脑细胞解决日常业务问题。\n\n#### Redux vs Mobx\n\n> 那么具体到这两种模型，又有一些特定的优缺点呈现出来，先谈谈 Redux 的优势：\n\n1. 数据流流动很自然，因为任何 dispatch 都会导致广播，需要依据对象引用是否变化来控制更新粒度。\n2. 如果充分利用时间回溯的特征，可以增强业务的可预测性与错误定位能力。\n3. 时间回溯代价很高，因为每次都要更新引用，除非增加代码复杂度，或使用 immutable。\n4. 时间回溯的另一个代价是 action 与 reducer 完全脱节，数据流过程需要自行脑补。原因是可回溯必然不能保证引用关系。\n5. 引入中间件，其实主要为了解决异步带来的副作用，业务逻辑或多或少参杂着 magic。\n6. 但是灵活利用中间件，可以通过约定完成许多复杂的工作。\n7. 对 typescript 支持困难。\n\nMobx：\n\n1. 数据流流动不自然，只有用到的数据才会引发绑定，局部精确更新，但免去了粒度控制烦恼。\n2. 没有时间回溯能力，因为数据只有一份引用。\n3. 自始至终一份引用，不需要 immutable，也没有复制对象的额外开销。\n4. 没有这样的烦恼，数据流动由函数调用一气呵成，便于调试。\n5. 业务开发不是脑力活，而是体力活，少一些 magic，多一些效率。\n6. 由于没有 magic，所以没有中间件机制，没法通过 magic 加快工作效率（这里 magic 是指 action 分发到 reducer 的过程）。\n7. 完美支持 typescript。\n\n\n### 到底如何选择\n\n\n从目前经验来看，我建议前端数据流不太复杂的情况，使用 Mobx，因为更加清晰，也便于维护；如果前端数据流极度复杂，建议谨慎使用 Redux，通过中间件减缓巨大业务复杂度，但还是要做到对开发人员尽量透明，如果可以建议使用 typescript 辅助。\n\n> https://zhuanlan.zhihu.com/p/25585910\n\n另一组对比：\n\n> https://zhuanlan.zhihu.com/p/25989654\n\n\n","tags":["javascript"],"categories":["科技"]},{"title":"Mobx使用详解及最佳实践","url":"/tech/mobx-study.html","content":"\n## 摘自：\n\n作者：Dominic_Ming\n链接：https://juejin.im/post/5a3b1a88f265da431440dc4a\n来源：掘金\n\n### stores 代表着UI状态\n\n永远记住，你的stores代表着你的UI状态，这就意味着，当你将你的stores储存下来后，就算你关了网页，再次打开，载入这个stores，你得到的网页也应该是相同的。虽然stores并不是一个本地数据库的角色，但是他依然存储着一些类似于按钮是否可见，input里面的内容之类的UI状态。\n\n```javascript\nclass SearchStore {\n  @observable searchText;\n\n  @action\n  setSearchText = (searchText) => {\n    this.searchText = searchText\n  }\n}\n\n@observer\nclass SearchInput extends React.Component {\n\n  handleInputChanged = (event) => {\n    const { searchStore } = this.props;\n    searchStore.setSearchText(event.target.value);\n  }\n\n  render() {\n    const { searchStore } = this.props;\n    return (\n      <input\n        value={searchStore.searchText}\n        onChange={this.handleInputChanged}\n      />\n    );\n  }\n}\n```\n\n### 将你的REST API请求和store的action分离\n不建议将REST API请求的函数放在stores里面，因为这样以来这些请求代码很难测试。你可以尝试把这些请求函数放在一个类里面，把这个类的代码和store放在一起，在store创建时，这个类也相应创建。然后当你测试时，你也可以优雅的把数据从这些类里面mock上去。\n\n```javascript\n\nclass TodoApi {\n\n  fetchTodos = () => request.get('/todos')\n}\n\nclass TodoStore {\n\n  @observable todos = [];\n\n  constructor(todoApi) {\n    this.todoApi = todoApi;\n  }\n\n  fetchTodos = async () => {\n    const todos = await this.todoApi.fetchTodos();\n\n    runInAction(() => {\n      this.todos = todos;\n    });\n  }\n}\n\n```\n\n// 在你的主要函数里面\n```javascript\nconst todoApi = new TodoApi();\nconst todoStore = new TodoStore(todoApi);\n```\n### 把你的业务逻辑放在stores里面\n尽量不要把业务逻辑写在你的组件里面。当你把业务逻辑写在组件里面的时候，你是没有办法来及时定位错误的，因为你的业务逻辑分散在各种不同的组件里面，让你很难来通过行为来定义到底是哪些代码涉及的这个错误。最好就把业务逻辑放在stores的方法里面，从组件里面调用。\n\n### 避免使用全局的store实例\n\n请尽量避免使用全局的store实例，因为这样你很难写出有条理而可靠的组件测试。取而代之的是，你可以使用Provider来把你的store inject到你的component实例的props里面。这样你就可以轻松的mock这些store来测试了。\n\n```javascript\nconst searchStore = new SearchStore();\n\nconst app = (\n  <Provider searchStore={searchStore}>\n    <SearchInput />\n  </Provider>\n);\n\nReactDom.render(app, container);\n```\n\n### 只有在store里面才允许改变属性\n\n请不要直接在组件里面直接操作store的属性值。因为只有store才能够来修改自己的属性。当你要改变属性的时候，请使用相应的store方法。不然的话你的属性修改会散落在各处不受控制，这是很难debug的。\n\n### 时刻记得在组件声明 @observer\n\n在每个组件声明的时候使用@observer来更新组件的状态。不然在嵌套组件里面，子组件没有声明的话，每次状态更新涉及到的都是父组件级的重新渲染。当你都使用了@observer时，重新渲染的组件数量会大大降低。\n\n### 使用 @computed\n就像下面代码的例子，使用@computed属性来处理一些涉及多个属性的逻辑。使用@computed可以减少这样的判断类业务逻辑在组件里面出现的频率。\n```javascript\nclass ApplicationStore {\n\n  @observable loggedInUser;\n\n  @observable isInAdminMode;\n\n  @computed isAdminButtonEnabled = () => {\n    return this.loggedInUser.role === 'admin' && this.isInAdminMode;\n  }\n}\n```\n\n### 你不需要 react router 来管理状态\n\n你不需要使用react router管理状态。就像我前面所说的，你的store就代表了应用的状态。当你让router来管理部份应用状态的时候，这部分状态就从store里面剥离开来。所以尽量使用store来储存所有的UI状态，这样store的属性就是你的界面所得。\n\n### 倾向于编写可控组件\n\n多编写可控组件，这样会大大降低你的测试复杂度，也让你的组件易于管理。\n\n\n","tags":["javascript"],"categories":["科技"]},{"title":"Redux架构学习","url":"/tech/redux-study.html","content":"\n## 整理自：\n\n资料：https://segmentfault.com/a/1190000006742449\n\nhttps://www.zhihu.com/question/41312576/answer/90782136\n\n\n### 一、定义\n\nRedux is a predictable state container for JavaScript apps.，其中predictable和state container体现了它的作用。那么如何来理解可预测化的呢？这里会有一些函数式编程方面的思想，在Redux中reducer函数是一个纯函数，相同输入一定会是一致的输出，所以确定输入的state那么reducer函数输出的state一定是可以被预测的，因为它只会进行单纯的计算，保证正确的输出。状态容器又是什么？说明Redux有一个专门管理state的地方，就是Store，并且一般情况下是唯一的，应用中所有state形成的一颗状态树就是Store。Redux由Flux演变而来，但受 Elm 的启发，避开了 Flux 的复杂性，我们看看其数据流向：\n\n![](/img/2018/15280237110062.jpg)\n\n不同于Flux架构，Redux中没有dispatcher这个概念，并且Redux设想你永远不会变动你的数据，你应该在reducer中返回新的对象来作为应用的新状态。但是它们都可以用(state, action) => newState来表述其核心思想，所以Redux可以被看成是Flux思想的一种实现，但是在细节上会有一些差异。\n\n### 二、原则\n1. 应用中所有的state都以一个object tree的形式存储在一个单一的store中；\n2. 唯一能改变store的方法是触发Action，Action是动作行为的抽象；\n3. 为了描述Action如何改变State树，需要编写reducer函数；\n\n```javascript\nfunction testReducer(state, action) {\n  switch (action.type) {\n    case ACTION_TYPE:\n      // calc...\n      return newState;\n    default: return state;\n  }\n  return newState;\n}\n```\n\nstate是不可修改的，所以返回的新state应该是基于输入state副本的修改，而不是直接修改state后的返回。\n可见\n1、单一数据源，store\n整个应用的state被存放在一棵Object tree树，并且整个object tree只存在唯一的一个store中。\n2、State是只读的\n唯一能改变State的方法是触发Action\n3、使用纯函数来实现State归并操作，reducer\n传入待修改的state和一个告知reducer如何修改state的action，reducer将返回action规则对应下操作后的新的state。\n\n> reducer(state, action) => new state\n\n\n### 三、数据流\n\n严格的单向数据流是Redux设计的核心\nRedux应用数据的生命周期遵循下面4个步骤：\n\n调用store.dispatch(action), 可以在任何地方进行;\nRedux store调用传入的reducer函数，并且将当前的state树与action传入。reducer是纯函数，只用于计算下一个state，它应该是完全可被预测的，相同的输入必定会有相同的输出，不能有副作用的操作，如API的调用或者路由跳转，这些应该都是在dispatch前产生；\n根reducer将多个子reducer输出合并成一个单一的state树；\nRedux store保存了根reducer返回的完整的state树。\n新的state树就是应用的下一个状态，现在就可以根据新的state tree来渲染UI\n\n1. React有props和state: props意味着父级分发下来的属性，state意味着组件内部可以自行管理的状态，并且整个React没有数据向上回溯的能力，也就是说数据只能单向向下分发，或者自行内部消化。\n理解这个是理解React和Redux的前提。\n2. 一般构建的React组件内部可能是一个完整的应用，它自己工作良好，你可以通过属性作为API控制它。但是更多的时候发现React根本无法让两个组件互相交流，使用对方的数据。\n然后这时候不通过DOM沟通（也就是React体制内）解决的唯一办法就是提升state，将state放到共有的父组件中来管理，再作为props分发回子组件。\n3. 子组件改变父组件state的办法只能是通过onClick触发父组件声明好的回调，也就是父组件提前声明好函数或方法作为契约描述自己的state将如何变化，再将它同样作为属性交给子组件使用。\n这样就出现了一个模式：数据总是单向从顶层向下分发的，但是只有子组件回调在概念上可以回到state顶层影响数据。这样state一定程度上是响应式的。\n4. 为了面临所有可能的扩展问题，最容易想到的办法就是把所有state集中放到所有组件顶层，然后分发给所有组件。\n5. 为了有更好的state管理，就需要一个库来作为更专业的顶层state分发给所有React应用，这就是Redux。让我们回来看看重现上面结构的需求：\na. 需要回调通知state (等同于回调参数) -> action\nb. 需要根据回调处理 (等同于父级方法) -> reducer\nc. 需要state (等同于总状态) -> store\n对Redux来说只有这三个要素：\na. action是纯声明式的数据结构，只提供事件的所有要素，不提供逻辑。\nb. reducer是一个匹配函数，action的发送是全局的：所有的reducer都可以捕捉到并匹配与自己相关与否，相关就拿走action中的要素进行逻辑处理，修改store中的状态，不相关就不对state做处理原样返回。\nc. store负责存储状态并可以被react api回调，发布action.\n当然一般不会直接把两个库拿来用，还有一个binding叫react-redux, 提供一个Provider和connect。很多人其实看懂了redux卡在这里。\na. Provider是一个普通组件，可以作为顶层app的分发点，它只需要store属性就可以了。它会将state分发给所有被connect的组件，不管它在哪里，被嵌套多少层。\nb. connect是真正的重点，它是一个科里化函数，意思是先接受两个参数（数据绑定mapStateToProps和事件绑定mapDispatchToProps），再接受一个参数（将要绑定的组件本身）：\nmapStateToProps：构建好Redux系统的时候，它会被自动初始化，但是你的React组件并不知道它的存在，因此你需要分拣出你需要的Redux状态，所以你需要绑定一个函数，它的参数是state，简单返回你关心的几个值。\nmapDispatchToProps：声明好的action作为回调，也可以被注入到组件里，就是通过这个函数，它的参数是dispatch，通过redux的辅助方法bindActionCreator绑定所有action以及参数的dispatch，就可以作为属性在组件里面作为函数简单使用了，不需要手动dispatch。这个mapDispatchToProps是可选的，如果不传这个参数redux会简单把dispatch作为属性注入给组件，可以手动当做store.dispatch使用。这也是为什么要科里化的原因。\n做好以上流程Redux和React就可以工作了。\n\n简单地说就是：\n1.顶层分发状态，让React组件被动地渲染。\n2.监听事件，事件有权利回到所有状态顶层影响状态。\n\n\n","tags":["前端","javascript"],"categories":["科技"]},{"title":"Flux架构理解","url":"/tech/flux-study.html","content":"\n\n### 1、是个什么鬼？\n\n> 如何理解 Facebook 的 flux 应用架构？\n\nFlux 的核心就是一个简单的约定：视图层组件不允许直接修改应用状态，只能触发 action。应用的状态必须独立出来放到 store 里面统一管理，通过侦听 action 来执行具体的状态操作。\n所谓的单向数据流，就是当用户进行操作的时候，会从组件发出一个 action，这个 action 流到 store 里面，触发 store 对状态进行改动，然后 store 又触发组件基于新的状态重新渲染。\n即可以看出：视图组件变得很薄，只包含了渲染逻辑和触发 action 这两个职责，即所谓 \"dumb components\"（愚蠢组件）\n\n### 2、结构图\n\n![](/img/2018/15280235400292.jpg)\n\n\n\n","tags":["javascript"],"categories":["科技"]},{"title":"Git回滚代码笔记","url":"/tech/git-revert.html","content":"\n总有那么一次操作后，想反悔，那么git log先：\n\n![](/img/2018/15280208525260.jpg)\n\n\n\n此时比如想恢复红框那个版本，执行：\n\n> git checkout 19d46ca0715df5223d9e30ba9743fc9d95a3bf78\n\n命令结束后，会跳到HEAD分支\n\n复制改项目到另一边，切回之前的分支，把备份覆盖回去。在 git diff 。对比一致后，在提交\n\n\n","tags":["码常规"],"categories":["科技"]},{"title":"Mac不能更改一个或多个项目因为他们正在使用的解决方法","url":"/tech/extended-attri-in-mac.html","content":"\n#### OS X 系统有的文件移动或复制时，出现“Mac 不能更改一个或多个项目,因为他们正在使用”，这或许是多了个属性导致：\n\n![](/img/2018/15280203394758.jpg)\n\n\n这就解决了，还有，如果是移动设备的文件导致的原因，解决时必须保证移动设备处于可读写状态，对于大部分移动硬盘都是NTFS的问题，可参考如下方法解决：\n\n[https://coolestguidesontheplanet.com/how-to-write-to-ntfs-external-disk-drives-from-os-x-10-11-el-capitan/](https://coolestguidesontheplanet.com/how-to-write-to-ntfs-external-disk-drives-from-os-x-10-11-el-capitan/)\n\n\n关于@的解释请参考：\n\n[http://mackuba.eu/2008/06/30/ls-on-mac-and-extended-file-attributes/](http://mackuba.eu/2008/06/30/ls-on-mac-and-extended-file-attributes/)\n\n\n","tags":["麦克","黑科技"],"categories":["科技"]},{"title":"Dealloc方法不个执行的三种最大可能","url":"/tech/dealloc-not-work.html","content":"\n今天写代码时需要在dealloc里移除所有的通知,但是却发现控制器pop后不执行dealloc方法.\n\n> 查到这句话:The dealloc method was not being called if any of the references held by a viewcontroller were still in memory.\n\ndealloc方法没有被调用是因为控制器的一个或多个强引用仍然在内存中,也就是说当前控制器的计数器不为0.\n一般的原因有以下几种:\n\n1. 定制器没有被销毁. \n    解决方法:在viewWillDisappear之前需要把控制器用到的NSTimer销毁.\n\n2. block块使用不当, 因为block会对方法中的变量自动retain一次, 请检查控制器中block代码.\n\n3. 代理必须得用weak修饰, 用strong强引用会导致计数器加1，无法释放内存.\n\n4. 在getter方法里使用self. 导致死循环\n\n\n\n> Block体内使用实例变量也会造成循环引用，使得拥有这个实例的对象不能释放。\n\n\n","tags":["objective-c","苹果"],"categories":["科技"]},{"title":"Swift与OC混编你需要知道的事情2","url":"/tech/swift-oc-coding.html","content":"\n### OC中的实例方法与类方法(+和-方法)\n\n![](/img/2018/15280192041769.jpg)\n\n\n\n","tags":["objective-c","swift"],"categories":["科技"]},{"title":"Swift与OC混编你需要知道的事情1","url":"/tech/swift-oc-coding.html","content":"\n### 在Swift中调用OC代码\n\n如果是纯OC项目，当你创建第一个Swift文件时，Xcode会提示你建立一个$(PROJECT_NAME)-Bridging-Header.h文件，这个文件就是OC与Swift间相互交流的桥梁文件，即：所有需要在Swift中调用的OC代码，OC头文件必须在这个文件里引入，相反如果是纯Swift项目，当你建立第一个OC语法的文件时，他也会提示，照做就可以了，酱紫就完成了Swift中调用OC。\n\n![](/img/2018/15280190471314.jpg)\n\n如果发现建立了桥接文件而项目无法正常编译时，请检查如上配置\n\n### 在OC中调用Swift代码\n\n由于Swift中没有头文件的概念，所有在OC中，直接引入Swift文件，编译器会不高兴的，结果就是编译无法通过！！！所以你需要在调用Swift的OC代码中，引入一个名叫：$(PROJECT_NAME)-Swift.h，这个文件中定义了该项目中所有Swift的类及其方法，不过他是不可见的\n\n![](/img/2018/15280190820933.jpg)\n\n","tags":["objective-c","苹果","swift"],"categories":["科技"]},{"title":"Swift命令行入坑","url":"/tech/swift-in-commandLine.html","content":"\n![](/img/2018/15280168301144.jpg)\n\n当然，Swift也可以编译后运行（二进制文件，直接执行）：\n\n![](/img/2018/15280168431585.jpg)\n\n\n\n","tags":["码常规","苹果","swift"],"categories":["科技"]},{"title":"AES/CBC模式关于加密解密头部缺失的可能性问题","url":"/tech/AES_CBC-iOS.html","content":"\n![](/img/2018/15280165964723.jpg)\n\n如果能解密出来，但是有乱码，如下：\n\n![](/img/2018/15280166141249.jpg)\n\n请考虑IV（初始化向量）是不是有误或两个平台下不一样\n====\n再有，Java端MD5可能直接返回了bytes，并没有最终转成String，注意多平台的区别\n\n![](/img/2018/15280166311066.jpg)\n\n\n\n","tags":["objective-c","java"],"categories":["科技"]},{"title":"performSelector May Cause a Leak Because Its Selector Is Unknown警告原因及其解决办法","url":"/tech/performSelector-warning-fix.html","content":"\n### 问题描述\n\n项目中使用到了从字符串创建选择器，编译时发现警告：\"performSelector may cause a leak because its selector is unknown\"（因为performSelector的选择器未知可能会引起泄漏），为什么在ARC模式下会出现这个警告？\n\n经过搜索后，在Stackoverflow上发现了一个令人满意的答案。见http://stackoverflow.com/questions/7017281/performselector-may-cause-a-leak-because-its-selector-is-unknown。\n\n### 原因\n\n在ARC模式下，运行时需要知道如何处理你正在调用的方法的返回值。这个返回值可以是任意值，如void,int,char,NSString,id等等。ARC通过头文件的函数定义来得到这些信息。所以平时我们用到的静态选择器就不会出现这个警告。因为在编译期间，这些信息都已经确定。\n\n如：\n\n```\n[someController performSelector:@selector(someMethod)];\n\n- (void)someMethod\n{\n  //bla bla...\n}\n```\n而使用[someController performSelector: NSSelectorFromString(@\"someMethod\")];时ARC并不知道该方法的返回值是什么，以及该如何处理？该忽略？还是标记为ns_returns_retained还是ns_returns_autoreleased?\n\n解决办法\n\n1.使用函数指针方式\n\n```\nSEL selector = NSSelectorFromString(@\"someMethod\");\nIMP imp = [_controller methodForSelector:selector];\nvoid (*func)(id, SEL) = (void *)imp;\nfunc(_controller, selector);\n```\n当有额外参数时，如\n\n```\nSEL selector = NSSelectorFromString(@\"processRegion:ofView:\");\nIMP imp = [_controller methodForSelector:selector];\nCGRect (*func)(id, SEL, CGRect, UIView *) = (void *)imp;\nCGRect result = func(_controller, selector, someRect, someView);\n```\n\n2.使用宏忽略警告\n\n```\n#pragma clang diagnostic push \n#pragma clang diagnostic ignored \"-Warc-performSelector-leaks\" \n   [someController performSelector: NSSelectorFromString(@\"someMethod\")]\n#pragma clang diagnostic pop\n```\n\n通过使用#pragma clang diagnostic push/pop，你可以告诉Clang编译器仅仅为某一特定部分的代码来忽视特定警告。\n\n如果需要忽视的警告有多处，可以定义一个宏\n\n```\n#define SuppressPerformSelectorLeakWarning(Stuff) \\\n    do { \\\n        _Pragma(\"clang diagnostic push\") \\\n        _Pragma(\"clang diagnostic ignored \\\"-Warc-performSelector-leaks\\\"\") \\\n        Stuff; \\\n        _Pragma(\"clang diagnostic pop\") \\\n    } while (0)\n    \n    ```\n在产生警告也就是performSelector的地方用使用该宏，如\n\n```\nSuppressPerformSelectorLeakWarning(\n    [_target performSelector:_action withObject:self]\n);\n```\n如果需要performSelector返回值的话，\n\n```\nid result;\nSuppressPerformSelectorLeakWarning(\n    result = [_target performSelector:_action withObject:self]\n);\n```\n3.使用afterDelay\n\n```\n[self performSelector:aSelector withObject:nil afterDelay:0.0];\n```\n如果在接受范围内，允许在下一个runloop执行，可以这么做。xCode5没问题，但据反映，xCode6的话这个不能消除警告。\n\n","tags":["objective-c","苹果"],"categories":["科技"]},{"title":"旋屏控制及宏定义","url":"/tech/interfaceOrientation-iOS.html","content":"\n```\n// 横屏设定的宏\n#define SetScreenOrientation \n- (BOOL)shouldAutorotate\n{\n    return YES;\n}\n\n- (NSUInteger)supportedInterfaceOrientations\n{\n    return UIInterfaceOrientationMaskLandscape;\n}\n//单斜杠是除法，双斜杠是注释，反斜杠可以链接宏定义，或连接字符串。\n```\n\n旋屏常用解释\n\n> UIInterfaceOrientationMaskLandscape  支持左右横屏\n> UIInterfaceOrientationMaskAll  支持四个方向旋转\n> UIInterfaceOrientationMaskAllButUpsideDown 支持除了UpsideDown以外的旋转\n\n当前屏幕方向interfaceOrientation的获取\n\n有3种方式可以获取到“当前interfaceOrientation”：\n\n```\ncontroller.interfaceOrientation，获取特定controller的方向\n[[UIApplication sharedApplication] statusBarOrientation] 获取状态条相关的方向\n[[UIDevice currentDevice] orientation] 获取当前设备的方向\n```\n\n\n\n","tags":["objective-c","苹果"],"categories":["科技"]},{"title":"三目运算赋值优良的写法","url":"/tech/three-unary-iOS.html","content":"\n```\n一般写法：\nfloat tempOffset = wordsDisplay == DisPlayBottom ? -80 : 80;\n\n优质写法：\n\nfloat offset = (DisPlayBottom == wordsDisplay) ? - 80 : 80;\n\n遵循常量放左边的原则\n\n三目运算也可以这么写：\nNSString *filetestpaht;\nfiletestpaht = filetestpaht ? : [NSString stringWithFormat:@\"abc\"];\n```\n\n","tags":["objective-c"],"categories":["科技"]},{"title":"iOS布局工具类","url":"/tech/pure-coding-layout-iOS.html","content":"\n```\n#import <Foundation/Foundation.h>\n\ntypedef enum\n{\n    AlignmentCenter = 0,\n    AlignmentTop,\n    AlignmentBottom,\n    AlignmentLeft,\n    AlignmentRight\n} PlaceAlignmentType;\n\n@interface PositionTools : NSObject\n\n// 针对默认为竖屏的有效\n+ (void)placeView:(UIView*)subview atTheCenterOfTheView:(UIView*)container;\n\n+ (void)placeView:(UIView*)subview atTheLeftMiddleOfTheView:(UIView*)container offset:(float)offset;\n+ (void)placeView:(UIView*)subview atTheRightMiddleOfTheView:(UIView*)container offset:(float)offset;\n+ (void)placeView:(UIView*)subview atTheTopMiddleOfTheView:(UIView*)container offset:(float)offset;\n+ (void)placeView:(UIView*)subview atTheBottomMiddleOfTheView:(UIView*)container offset:(float)offset;\n\n+ (void)placeView:(UIView*)subview atTheLeftTopOfTheView:(UIView*)container offset:(CGSize)offset;\n+ (void)placeView:(UIView*)subview atTheRightTopOfTheView:(UIView*)container offset:(CGSize)offset;\n+ (void)placeView:(UIView*)subview atTheLeftBottomOfTheView:(UIView*)container offset:(CGSize)offset;\n+ (void)placeView:(UIView*)subview atTheRightBottomOfTheView:(UIView*)container offset:(CGSize)offset;\n\n+ (void)placeView:(UIView *)sourceView toTheRightOfTheView:(UIView*)targetView span:(float)span;\n+ (void)placeView:(UIView *)sourceView toTheLeftOfTheView:(UIView*)targetView span:(float)span;\n+ (void)placeView:(UIView *)sourceView aboveTheView:(UIView*)targetView span:(float)span;\n+ (void)placeView:(UIView *)sourceView belowTheView:(UIView*)targetView span:(float)span;\n\n+ (void)placeView:(UIView *)sourceView toTheRightOfTheView:(UIView*)targetView span:(float)span alignmentType:(PlaceAlignmentType)alignmentType;\n+ (void)placeView:(UIView *)sourceView toTheLeftOfTheView:(UIView*)targetView span:(float)span alignmentType:(PlaceAlignmentType)alignmentType;\n+ (void)placeView:(UIView *)sourceView aboveTheView:(UIView*)targetView span:(float)span alignmentType:(PlaceAlignmentType)alignmentType;\n+ (void)placeView:(UIView *)sourceView belowTheView:(UIView*)targetView span:(float)span alignmentType:(PlaceAlignmentType)alignmentType;\n\n// 用来处理横屏的情况下，在屏幕没有旋转到横屏位置之前的情况\n+ (void)placeView:(UIView*)subview atTheCenterOfTheView:(UIView*)container needAlter:(BOOL)needAlter;\n\n+ (void)placeView:(UIView*)subview atTheLeftMiddleOfTheView:(UIView*)container offset:(float)offset needAlter:(BOOL)needAlter;\n+ (void)placeView:(UIView*)subview atTheRightMiddleOfTheView:(UIView*)container offset:(float)offset needAlter:(BOOL)needAlter;\n+ (void)placeView:(UIView*)subview atTheTopMiddleOfTheView:(UIView*)container offset:(float)offset needAlter:(BOOL)needAlter;\n+ (void)placeView:(UIView*)subview atTheBottomMiddleOfTheView:(UIView*)container offset:(float)offset needAlter:(BOOL)needAlter;\n\n+ (void)placeView:(UIView*)subview atTheRightTopOfTheView:(UIView*)container offset:(CGSize)offset needAlter:(BOOL)needAlter;\n+ (void)placeView:(UIView*)subview atTheLeftBottomOfTheView:(UIView*)container offset:(CGSize)offset needAlter:(BOOL)needAlter;\n+ (void)placeView:(UIView*)subview atTheRightBottomOfTheView:(UIView*)container offset:(CGSize)offset needAlter:(BOOL)needAlter;\n\n@end\n```\n\n实现\n\n```\n#import \"PositionTools.h\"\n\n@implementation PositionTools\n\n+ (void)placeView:(UIView*)subview atTheCenterOfTheView:(UIView*)container\n{\n    return [self placeView:subview atTheCenterOfTheView:container needAlter:NO];\n}\n\n+ (void)placeView:(UIView*)subview atTheLeftMiddleOfTheView:(UIView*)container offset:(float)offset\n{\n    return [self placeView:subview atTheLeftMiddleOfTheView:container offset:offset needAlter:NO];\n}\n\n+ (void)placeView:(UIView*)subview atTheRightMiddleOfTheView:(UIView*)container offset:(float)offset\n{\n    return [self placeView:subview atTheRightMiddleOfTheView:container offset:offset needAlter:NO];\n}\n\n+ (void)placeView:(UIView*)subview atTheTopMiddleOfTheView:(UIView*)container offset:(float)offset\n{\n    return [self placeView:subview atTheTopMiddleOfTheView:container offset:offset needAlter:NO];\n}\n\n+ (void)placeView:(UIView*)subview atTheBottomMiddleOfTheView:(UIView*)container offset:(float)offset\n{\n    return [self placeView:subview atTheBottomMiddleOfTheView:container offset:offset needAlter:NO];\n}\n\n+ (void)placeView:(UIView*)subview atTheRightTopOfTheView:(UIView*)container offset:(CGSize)offset\n{\n    return [self placeView:subview atTheRightTopOfTheView:container offset:offset needAlter:NO];\n}\n\n+ (void)placeView:(UIView*)subview atTheLeftBottomOfTheView:(UIView*)container offset:(CGSize)offset\n{\n    return [self placeView:subview atTheLeftBottomOfTheView:container offset:offset needAlter:NO];\n}\n\n+ (void)placeView:(UIView*)subview atTheRightBottomOfTheView:(UIView*)container offset:(CGSize)offset\n{\n    return [self placeView:subview atTheRightBottomOfTheView:container offset:offset needAlter:NO];\n}\n\n+ (void)placeView:(UIView*)subview atTheCenterOfTheView:(UIView*)container needAlter:(BOOL)needAlter\n{\n    [container addSubview:subview];\n    \n    if (needAlter) {\n        subview.center = CGPointMake(container.bounds.size.height/2, container.bounds.size.width/2);\n    } else {\n        subview.center = CGPointMake(container.bounds.size.width/2, container.bounds.size.height/2);\n    }\n}\n\n+ (void)placeView:(UIView*)subview atTheLeftMiddleOfTheView:(UIView*)container offset:(float)offset needAlter:(BOOL)needAlter\n{\n    [container addSubview:subview];\n    \n    if (needAlter) {\n        subview.center = CGPointMake(offset + subview.frame.size.width/2, container.bounds.size.width/2);\n    } else {\n        subview.center = CGPointMake(offset + subview.frame.size.width/2, container.bounds.size.height/2);\n    }\n}\n\n+ (void)placeView:(UIView*)subview atTheRightMiddleOfTheView:(UIView*)container offset:(float)offset needAlter:(BOOL)needAlter\n{\n    [container addSubview:subview];\n    \n    if (needAlter) {\n        subview.center = CGPointMake(container.bounds.size.height - (offset + subview.frame.size.width/2), container.bounds.size.width/2);\n    } else {\n        subview.center = CGPointMake(container.bounds.size.width - (offset + subview.frame.size.width/2), container.bounds.size.height/2);\n    }\n}\n\n+ (void)placeView:(UIView*)subview atTheTopMiddleOfTheView:(UIView*)container offset:(float)offset needAlter:(BOOL)needAlter\n{\n    [container addSubview:subview];\n    \n    if (needAlter) {\n        subview.center = CGPointMake(container.bounds.size.height/2, offset + subview.frame.size.height/2);\n    } else {\n        subview.center = CGPointMake(container.bounds.size.width/2, offset + subview.frame.size.height/2);\n    }\n}\n\n+ (void)placeView:(UIView*)subview atTheBottomMiddleOfTheView:(UIView*)container offset:(float)offset needAlter:(BOOL)needAlter\n{\n    [container addSubview:subview];\n    \n    if (needAlter) {\n        subview.center = CGPointMake(container.bounds.size.height/2,  container.bounds.size.width - (offset + subview.frame.size.height/2));\n    } else {\n        subview.center = CGPointMake(container.bounds.size.width/2,  container.bounds.size.height - (offset + subview.frame.size.height/2));\n    }\n}\n\n+ (void)placeView:(UIView*)subview atTheLeftTopOfTheView:(UIView*)container offset:(CGSize)offset\n{\n    [container addSubview:subview];\n    \n    subview.center = CGPointMake(offset.width + subview.frame.size.width/2,\n                                 offset.height + subview.frame.size.height/2);\n}\n\n+ (void)placeView:(UIView*)subview atTheRightTopOfTheView:(UIView*)container offset:(CGSize)offset needAlter:(BOOL)needAlter\n{\n    [container addSubview:subview];\n    \n    if (needAlter) {\n        subview.center = CGPointMake(container.bounds.size.height - (offset.width + subview.frame.size.width/2),\n                                     offset.height + subview.frame.size.height/2);\n    } else {\n        subview.center = CGPointMake(container.bounds.size.width - (offset.width + subview.frame.size.width/2),\n                                     offset.height + subview.frame.size.height/2);\n    }\n}\n\n+ (void)placeView:(UIView*)subview atTheLeftBottomOfTheView:(UIView*)container offset:(CGSize)offset needAlter:(BOOL)needAlter\n{\n    [container addSubview:subview];\n    \n    if (needAlter) {\n        subview.center = CGPointMake(offset.width + subview.frame.size.width/2,\n                                     container.bounds.size.width - (offset.height + subview.frame.size.height/2));\n    } else {\n        subview.center = CGPointMake(offset.width + subview.frame.size.width/2,\n                                     container.bounds.size.height - (offset.height + subview.frame.size.height/2));\n    }\n}\n\n+ (void)placeView:(UIView*)subview atTheRightBottomOfTheView:(UIView*)container offset:(CGSize)offset needAlter:(BOOL)needAlter\n{\n    [container addSubview:subview];\n    \n    if (needAlter) {\n        subview.center = CGPointMake(container.bounds.size.height - (offset.width + subview.frame.size.width/2),\n                                     container.bounds.size.width - (offset.height + subview.frame.size.height/2));\n    } else {\n        subview.center = CGPointMake(container.bounds.size.width - (offset.width + subview.frame.size.width/2),\n                                     container.bounds.size.height - (offset.height + subview.frame.size.height/2));\n    }\n}\n\n+ (void)placeView:(UIView *)sourceView toTheRightOfTheView:(UIView*)targetView span:(float)span\n{\n    [self placeView:sourceView toTheRightOfTheView:targetView span:span alignmentType:AlignmentCenter];\n}\n\n+ (void)placeView:(UIView *)sourceView toTheLeftOfTheView:(UIView*)targetView span:(float)span\n{\n    [self placeView:sourceView toTheLeftOfTheView:targetView span:span alignmentType:AlignmentCenter];\n}\n\n+ (void)placeView:(UIView *)sourceView aboveTheView:(UIView*)targetView span:(float)span\n{\n    [self placeView:sourceView aboveTheView:targetView span:span alignmentType:AlignmentCenter];\n}\n\n+ (void)placeView:(UIView *)sourceView belowTheView:(UIView*)targetView span:(float)span\n{\n    [self placeView:sourceView belowTheView:targetView span:span alignmentType:AlignmentCenter];\n}\n\n+ (void)placeView:(UIView*)sourceView toTheRightOfTheView:(UIView*)targetView span:(float)span alignmentType:(PlaceAlignmentType)alignmentType\n{\n    [[targetView superview] addSubview:sourceView];\n    sourceView.center = CGPointMake(targetView.frame.origin.x + targetView.frame.size.width + (span + sourceView.frame.size.width/2),\n                                    targetView.center.y);\n    [self alignView:sourceView targetView:targetView alignmentType:alignmentType];\n}\n\n+ (void)placeView:(UIView*)sourceView toTheLeftOfTheView:(UIView*)targetView span:(float)span alignmentType:(PlaceAlignmentType)alignmentType\n{\n    [[targetView superview] addSubview:sourceView];\n    sourceView.center = CGPointMake(targetView.frame.origin.x - (span + sourceView.frame.size.width/2),\n                                    targetView.center.y);\n    [self alignView:sourceView targetView:targetView alignmentType:alignmentType];\n}\n\n+ (void)placeView:(UIView*)sourceView aboveTheView:(UIView*)targetView span:(float)span alignmentType:(PlaceAlignmentType)alignmentType\n{\n    [[targetView superview] addSubview:sourceView];\n    sourceView.center = CGPointMake(targetView.center.x,\n                                    targetView.frame.origin.y - (span + sourceView.frame.size.height/2));\n    [self alignView:sourceView targetView:targetView alignmentType:alignmentType];\n}\n\n+ (void)placeView:(UIView*)sourceView belowTheView:(UIView*)targetView span:(float)span alignmentType:(PlaceAlignmentType)alignmentType\n{\n    [[targetView superview] addSubview:sourceView];\n    sourceView.center = CGPointMake(targetView.center.x,\n                                    targetView.frame.origin.y + targetView.frame.size.height + (span + sourceView.frame.size.height/2));\n    [self alignView:sourceView targetView:targetView alignmentType:alignmentType];\n}\n\n+ (void)alignView:(UIView*)sourceView targetView:(UIView*)targetView alignmentType:(PlaceAlignmentType)alignmentType\n{\n    if (AlignmentTop == alignmentType) {\n        sourceView.center = CGPointMake(sourceView.center.x,\n                                        targetView.frame.origin.y + sourceView.frame.size.height/2);\n    } else if (AlignmentBottom == alignmentType) {\n        sourceView.center = CGPointMake(sourceView.center.x,\n                                        targetView.frame.origin.y + targetView.frame.size.height - sourceView.frame.size.height/2);\n    } else if (AlignmentLeft == alignmentType) {\n        sourceView.center = CGPointMake(targetView.frame.origin.x + sourceView.frame.size.width/2,\n                                        sourceView.center.y);\n    } else if (AlignmentRight == alignmentType) {\n        sourceView.center = CGPointMake(targetView.frame.origin.x + targetView.frame.size.width - sourceView.frame.size.width/2,\n                                        sourceView.center.y);\n    }\n}\n@end\n```\n\n\n","tags":["objective-c","苹果"],"categories":["科技"]},{"title":"iOS命令行打包","url":"/tech/ipa-command-packaging.html","content":"\n### 1、概述：\n\n打包这事儿其实就是让`xcrun`来干，而`xcodebuild`只是`xcrun`的一个软链接。分工如下：\n> 1、`xcodebuild`负责讲工程源文件编译成xxx.app；\n> 2、`xcrun`负责给xxx.app签名并打包成xxx.ipa\n\n### 2、工作步骤：\n\n1、先查看本机命令编译环境及需要编译项目的信息：\n\n![](/img/2018/15280148179275.jpg)\n\n2、开始编译：\n\n> 1、清理：xcodebuild -target Test clean  \n> 2、编译：xcodebuild -target Test\n> 3、打包：xcrun -sdk iphoneos PackageApplication -v ./build/Release-iphoneos/Test.app -o ~/ipas/test.ipa\n\n\n### 3、查看结果：\n\n![](/img/2018/15280149958188.jpg)\n\n### 4、特别提示：\n> 以上打包方式仅对`*.xcodeproj`项目有效，如果是cocoapod项目，则需要改一遍编译命令：\n\n\n```\n\nxcodebuild -workspace Test.xcworkspace -scheme Test -configuration Release -derivedDataPath build\n\n```\n\n\n","tags":["码常规","苹果"],"categories":["科技"]},{"title":"iOS属性最佳实践","url":"/tech/property-in-action-iOS.html","content":"\n### 一、关于objective-C的属性，常见的有：strong、weak、copy、assign\n\n1. 对于基本数据类型，当然使用assigin；\n2. 对于mutable的，一定要使用strong。父控件UI元素也使用strong；\n3. 子控件元素使用weak；\n4. 不可变的类型，使用copy。（NSString,NSArray,NSDictonary这些一定要用copy）对于mutable的对象，如果是mutable的却定义属性为copy，则往里面加值时可能引起程序崩溃。而对于不可变的使用了strong，则可能引起值改变，这就违背了内存管理语义\n\n### 二、关于getter\n\n![](/img/2018/15280142068491.jpg)\n\n![](/img/2018/15280142123608.jpg)\n\n```\nif (_messageTipNumber > 0) {\n        self.tipCountLable.frame = CGRectMake(150, (self.frame.size.height - 14)/2, 14, 14);\n        self.tipCountLable.layer.cornerRadius = _tipCountLable.frame.size.width/2;\n        self.tipCountLable.text = [NSString stringWithFormat:@\"%d\",_messageTipNumber];\n        [self.contentView addSubview:_tipCountLable];\n}\n```\n\n\n","tags":["objective-c","苹果"],"categories":["科技"]},{"title":"改变pushViewController的push方向","url":"/tech/pushViewController-change.html","content":"\n```\nCATransition* transition = [CATransition animation];\n\ntransition.type = kCATransitionPush;//可更改为其他方式\n\ntransition.subtype = kCATransitionFromTop;//可更改为其他方式   \n\n[self.navigationController.view.layera ddAnimation:transition forKey:kCATransition];\n\n[self.navigationController pushViewController:userLogin animated:NO];\n\n```\n\n再来\n\n```\n//可根据上一个页面，来确定当前页以何种方式消失\n- (void)viewWillDisappear:(BOOL)animated\n{\n    [super viewWillDisappear:animated];\n    [self clear];\n    BOOL fromRight = YES;\n    NSArray *viewControllers = self.navigationController.viewControllers;\n    if ([[viewControllers lastObject] isKindOfClass:[BFEAddContactViewController class]]) {\n        fromRight = NO;\n    }\n    CATransition *transition = [CATransition animation];\n    transition.type = kCATransitionPush;\n    //页面卸载时，改变PUSH方向\n    transition.subtype = fromRight ?  kCATransitionFromRight : kCATransitionFromLeft;\n    transition.duration = 0.3;\n    transition.delegate = self;\n    [self.navigationController.view.layer addAnimation:transition forKey:kCATransition];\n}\n```\n\n\n","tags":["objective-c","苹果"],"categories":["科技"]},{"title":"iOS随机数获取","url":"/tech/random-objectiveC.html","content":"\nios 有如下三种随机数方法：\n\n```\n1.    srand((unsigned)time(0));  //不加这句每次产生的随机数不变\n        int i = rand() % 5;      \n\n2.    srandom(time(0));\n        int i = random() % 5;\n\n3.    int i = arc4random() % 5 ;\n```\n \n\n注：rand()和random()实际并不是一个真正的伪随机数发生器，在使用之前需要先初始化随机种子，否则每次生成的随机数一样。\n\narc4random() 是一个真正的伪随机算法，不需要生成随机种子，因为第一次调用的时候就会自动生成。而且范围是rand()的两倍。在iPhone中，RAND_MAX是0x7fffffff (2147483647)，而arc4random()返回的最大值则是 0x100000000 (4294967296)。\n\n精确度比较：arc4random()  >  random()  >  rand()。\n\n \n\n常用方法：arc4random\n\n \n\n1、获取一个随机整数范围在：[0,100)包括0，不包括100\n\nint x = arc4random() % 100;\n\n2、  获取一个随机数范围在：[500,1000），包括500，不包括1000\n\nint y = (arc4random() % 501) + 500;\n\n3、获取一个随机整数，范围在[from,to），包括from，不包括to\n\n```\n-(int)getRandomNumber:(int)from to:(int)to\n{\n    return (int)(from + (arc4random() % (to – from + 1))); //+1,result is [from to]; else is [from, to)!!!!!!!\n\n}\n\n```\n\n","tags":["objective-c","苹果"],"categories":["科技"]},{"title":"iOS页面间几种传值方式","url":"/tech/data-pass-in-iOS.html","content":"\n### 属性：\n\n在继承关系下，子类使用父类的数据通过属性最为合适，也最直接明了。\n\n### Block：\n\n如果有某种继承或所属关系时，父元素要使用子元素的数据，那么此时应该使用block回调。因为此时子元素属性就不一定能取到值（初始化未或动作未必完成）。\n\n### 消息：\n\n两个类根本没有关联，则可以采取发消息的方式。如果两个类可以引入某一方，则还是采取属性或者block方法，因为发消息实际上通过KVO比较消耗系统资源。能不发消息，尽量不要发消息。\n\n\n","tags":["objective-c","苹果"],"categories":["科技"]},{"title":"UIView事件独占","url":"/tech/exclusiveTouch-iOS.html","content":"\n### UIView 的exclusiveTouch属性\n\nexclusiveTouch的意思是UIView会独占整个Touch事件，具体的来说，就是当设置了exclusiveTouch的 UIView是事件的第一响应者，那么到你的所有手指离开前，其他的视图UIview是不会响应任何触摸事件的，对于多点触摸事件，这个属性就非常重要，值得注意的是：手势识别（GestureRecognizers）会忽略此属性。\n\n列举用途：我们知道ios是没有GridView视图的，通常做法是在UITableView的cell上加载几个子视图，来模拟实现 GridView视图，但对于每一个子视图来说，就需要使用exclusiveTouch，否则当同时点击多个子视图，那么会触发每个子视图的事件。当然 还有我们常说的模态对话框。\n\n","tags":["objective-c","苹果"],"categories":["科技"]},{"title":"iOS关于指针定义","url":"/tech/iOS-Pointer.html","content":"\n\n### 关于指针定义（解决 sending 'const NSString *' to parameter of type 'NSString *' ）\n\n```\n比如，写了 const NSString* firstString = @\"xxx\";\nNSString* secondString = @\"yyy\";\n[secondString isEqualToString:firstString];\n\n会出现 sending 'const NSString *' to parameter of type 'NSString *' discards qualifiers 警告。\n解决办法：\n把 const NSString* firstString = @\"xxx\";\n改成 NSString* const firstString = @\"xxx\";\n```\n\n解释：前者相当于指针本身不可修改，后者表示指针指向的内容不可修改，两者的作用都是使firstString只可读不可写。\n\n","tags":["objective-c","苹果"],"categories":["科技"]},{"title":"NSScanner，扫描器","url":"/tech/NSScanner.html","content":"\n```\n- (void)testScanNumberFromString\n{\n    NSString *str = @\"98234hk323hello234你好\";\n    NSMutableString *numberString = [[NSMutableString alloc] init];\n    \n    NSScanner *scanner = [NSScanner scannerWithString:str];\n    NSString *tempString;\n    \n    while (![scanner isAtEnd]) {\n        [scanner scanUpToCharactersFromSet:[NSCharacterSet decimalDigitCharacterSet] intoString:nil];\n        \n        //收集数字\n        [scanner scanCharactersFromSet:[NSCharacterSet decimalDigitCharacterSet] intoString:&tempString];;\n        [numberString appendString:tempString];\n        tempString = @\"\";\n    }\n    NSLog(@\"@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ number is: %@\",numberString);\n}\n```\n\n使用\n\n```\n[scanner scanUpToCharactersFromSet:[NSCharacterSet newlineCharacterSet] intoString:&indexString]; //扫描一行\n[scanner scanUpToString:@\" scanover \" intoString:&theString];  //从游标开始扫描，直到给定字符串为止。期间扫描的字符串存到theString\n[scanner scanString:@\"sanMe\" intoString:NULL]; //直接扫描指定字符串\n\n```\n\n","tags":["objective-c","苹果"],"categories":["科技"]},{"title":"IOS中URL编码和解码","url":"/tech/url-encoding-iOS.html","content":"\n```\nint main(int argc, const char * argv[]) {\n    \n    NSString *str = @\"白日依山尽\";\n    \n    //编码\n    NSString *encoderStr = [str stringByAddingPercentEscapesUsingEncoding:NSUTF8StringEncoding];\n    \n    //解码\n    NSString *decoderStr = [encoderStr stringByReplacingPercentEscapesUsingEncoding:NSUTF8StringEncoding];\n    \n    //字符串打散\n    for (int i = 0; i < str.length; i++) {\n        NSString *word = [str substringWithRange:NSMakeRange(i, 1)];\n        NSLog(@\"%@\",word);\n    }\n    \n    \n    NSLog(@\"%@\",encoderStr);\n    \n    NSLog(@\"%@\",decoderStr);\n    \n    return 0;\n}\n```\n\n\n","tags":["objective-c","苹果"],"categories":["科技"]},{"title":"Id和instancetype的异同","url":"/tech/instancetype-iOS.html","content":"\n1、相同点\n\n都可以作为方法的返回类型\n\n2、不同点\n\n①instancetype可以返回和方法所在类相同类型的对象，id只能返回未知类型的对象；\n②instancetype只能作为返回值，不能像id那样作为参数，比如下面的写法：\n\n```\n//err,expected a type  \n- (void)setValue:(instancetype)value  \n{  \n    //do something  \n}  \n\n```\n\n就是错的，应该写成：\n\n```\n- (void)setValue:(id)value  \n{  \n    //do something  \n}  \n```\n\n\n","tags":["objective-c","苹果"],"categories":["科技"]},{"title":"MRC和ARC混编","url":"/tech/mrc-and-arc.html","content":"\n从XCode5以后，默认都采用了ARC，但有时候又想使用MRC，无奈写了MRC语法后，编译器保持：\n\n![](/img/2018/15280126158577.jpg)\n\n解决方式如下：\n\n![](/img/2018/15280126834131.jpg)\n\n> 注意：-fno-objc-arc 这句不要有空格。\n\nMRC工程中也可以使用ARC的类。方法如下：\n\n在targets的build phases选项下Compile Sources下选择要使用arc编译的文件，双击它，输入 -fobjc-arc 即可\n\n\n","tags":["objective-c","苹果"],"categories":["科技"]},{"title":"属性变量（Property）与成员变量的区别","url":"/tech/property-and-memberVar-in-iOS.html","content":"\n```\n@interface MyViewController :UIViewControlle\n{\n    UIButton *myButton;\n}\n@property (nonatomic, retain) UIButton *myButton;\n@end\n\n```\n\n类与类别中添加的属性要区分开来，因为类别中只能添加方法，不能添加实例变量。经常会在ios的代码中看到在类别中添加属性，这种情况下，是不会自动生成实例变量的。比如在：UINavigationController.h文件中会对UIViewController类进行扩展\n\n```\n@interface UIViewController (UINavigationControllerItem)\n@property(nonatomic,readonly,retain) UINavigationItem *navigationItem;\n@property(nonatomic) BOOL hidesBottomBarWhenPushed;\n@property(nonatomic,readonly,retain) UINavigationController *navigationController;\n@end\n\n```\n\n这里添加的属性，不会自动生成实例变量，这里添加的属性其实是添加的getter与setter方法。\n\n> 注意一点，匿名类别(匿名扩展)是可以添加实例变量的，非匿名类别是不能添加实例变量的，只能添加方法，或者属性（其实也是方法）。\n\n成员变量用于类内部，无需与外界接触的变量。\n\n根据成员变量的私有性，为了方便访问，所以就有了属性变量。属性变量的好处就是允许让其他对象访问到该变量。当然，你可以设置只读或者可写等，设置方法也可自定义。所以，属性变量是用于与其他对象交互的变量。\n一些建议:\n\n1. 如果只是单纯的private变量，最好声明在implementation里.\n2. 如果是类的public属性，就用property写在.h文件里\n3. 如果自己内部需要setter和getter来实现一些东西，就在.m文件的类目里用property来声明\n\n\n","tags":["objective-c","苹果"],"categories":["科技"]},{"title":"将Hexo博客url优化进行到底","url":"/tech/permalink-optimize-hexo.html","content":"\n## 事件源自2017年元旦时的一篇博文\n\n[在hexo博客中打造相对完美的URL](https://blog.tangkunyin.com/tech/hexo-links-1483800845.html)\n\n那篇文章，我向大家介绍了如何在hexo博客中打造一个相对好看、好用的URL链接。然而遗憾的是，**时间戳**在permalink中没法直接使用。当时说了一个笨办法，就是模板中手动去加时间戳，然后文章生成是再取出来。不知道使用过的朋友有没有喷我...\n\n时隔一年多，我又准备玩hexo了，理由是被类似**为知笔记**这种东西伤透了心。\n\n然而也是一年多过去了，官方并没有做这样的支持，那我就不高兴了。在强迫症的驱使下，我读了他的源码，发现加这个时间戳相当简单，所以我义不容辞的提了这个[PR](https://github.com/hexojs/hexo/pull/3162)。这是半个月前发生的事情，在我写这篇文章的时候，官方还没有Merge。所以你如果想在**permalink**中使用时间戳。办法就是人肉把**node_module**文件夹下指定的文件做修改。怎么改？改哪个文件？改成啥样？请直接看那个PR。\n\n如果一切顺利，你现在就能愉快的玩耍了。比如：\n\n> https://blog.tangkunyin.com/tech/permalink-optimize-hexo-1528003174.html\n\n当然别忘了配置站点**_config.yml**\n\n> permalink: :category/:entitle/:timestamp.html\n\n最后，祝读者们儿童节快乐！\n\n### 再来看\n\n==========来自2018圣诞节的更新===============\n\n最近升级了NPM、NodeJS及Hexo依赖库，发现时间戳不好使了。（PS：之前人肉改了Hexo的源码，看上去并没有被Merge...）\n\n于是有了补丁包，操作姿势：\n\n```shell\n\n1. mkdir patch/  && cd patch\n\n2. touch run.sh && vim run.sh\n\n#!/bin/sh\n\ncp ./scripts/post.js ../node_modules/hexo/lib/hexo\ncp ./scripts/scaffold.js ../node_modules/hexo/lib/hexo\n\n3. mkdir scripts\n// 将node_modules/hexo/lib/hexo对应的文件复制到新建的这个目录中。内容做点更改。更改内容参见上面提到的PR\n\n\n4. chmod 775 run.sh && ./run.sh\n\n5. hexo n test\n// 是不是发现时间戳被加回来了....\n\n```\n\n\n","tags":["hexo","web"],"categories":["科技"]},{"title":"是时候抛弃你的OFFICE全家桶了","url":"/tech/nodeppt.html","content":"\n![blackTech](/img/2017/blackTech.png)\n\n### 今天要说的是一个很炫的东西，叫做**NodePPT**\n\n你是否有这种场景，辛苦做好一份`PPT`，然后发文件给其他人，奈何人家用的`macOS`且没有装微软全家桶，如果有`Keynote`还算好。想表达的意思就是通过这样的`Native`端办公软件，在跨平台协作上，难免会「丢真」。而今天的主角，将以极客化的方式为你继续`PPT`之路，让你越来越喜欢装逼......\n\n#### 项目地址\n\n> let's look look...  [demo](http://js8.in/nodeppt/)\n\n源码：[nodeppt](https://github.com/ksky521/nodeppt)\n\n文档：[推荐nodeppt：使用markdown语法来写网页ppt](http://js8.in/2013/11/16/%E6%8E%A8%E8%8D%90nodeppt%EF%BC%9A%E4%BD%BF%E7%94%A8markdown%E8%AF%AD%E6%B3%95%E6%9D%A5%E5%86%99%E7%BD%91%E9%A1%B5ppt/)\n\n#### 安装使用啥的，官方文档说的很清楚，以下为我使用笔记\n\n1 升级版本：\n\n> npm update -g nodeppt\n\n2 创建一个文档：\n\n```\n// a. 执行如下命令\nnodeppt create hello\n\n// b. 交互式信息补充\nplease input：\ntitle (slide title) Hello\nsubtitle world\nspeaker (speaker) Thomas Tang\nSuccess：hello.md, please write your slide content\n\n// c. 使用MWeb之类的MD工具开始愉快的编写ppt吧~\n```\n\n3 启动预览\n\n```shell\n// 其中，-w表示watch模式，即：改动会时时生效，无需手动刷新浏览器。有没有很*的样子\nnodeppt start -w -p 9090\n```\n\n#### 将写好的PPT作为gitpages服务发布\n\n1 导出全部，包括nodeppt的js、img和css文件夹到执行目录下，如：docs\n\n```\nnodeppt generate . docs -a\n```\n\n> 目前发现两个问题，首先生成docs目录里，还有一个docs目录，在接着执行命令，还会继续生成。直接删掉不需要的目录；其次第一步生成的docs目录用了`Git`初始化，这就是说如果你的根目录已经用了Git管理，再套一层会导致推送到GitHub对应的目录没有文件，而`git status`会出现：**modified:   docs (modified content, untracked content)**。解决办法还是删掉`.git`和`.gitignore`\n\n\n2 有了docs目录后，本地打开里面的`index.html`，看看样式对不对，没问题之后再进行第三步\n\n3 在GitHub Pages的`Source`处，选择：`Use only the /docs folder for GitHub Pages`\n\n4 访问配置好的域名，如`http://ppt.blog.tangkunyin.com`，就可以远程访问ppt了，这并不需要你在任何平台安装office全家桶\n\n5 剩下的工作就是发挥创造力，码字，做交互。每次写完重复以上步骤就可以使得ppt更新\n\n\n\n\n\n","tags":["javascript","黑科技"],"categories":["科技"]},{"title":"开始使用Swift语言开发后台","url":"/tech/swift-in-serverside.html","content":"\n### 先分享核心项目和资料\n\n#### Swift in server side\n\n[Perfect](https://github.com/PerfectlySoft/Perfect)\n\n\n#### Documentation\n\n[Chinese Doc of Perfect](http://perfect.org/docs/gettingStarted_zh_CN.html)\n\n#### Discuss Channel in Slack\n\n[Slack](http://www.perfect.ly/)\n\n\n\n##### 后续的事情\n\n> 之前立了一块牌坊，却始终没有内容，感觉不太合适，后续的笔记，整理整理再发上来....\n\n\n\n","tags":["swift","后端"],"categories":["科技"]},{"title":"JSimple主题用户指南","url":"/tech/jsimple-usage.html","content":"\n![hexo-blog-basic](/img/2017/hexo-blog-basic.jpg)\n\n### 本文将持续跟进主题更新，除了Github的文档，就这里更详细了，有错误发现和建议可以直接提在本文后头\n\n> 任何的软件作品，不论是成品还是半成品，提供一份易懂的说明还是很重要也非常有必要的。在这件事情上，我很抱歉！因为主题制作过程本来断断续续，开始我也只是想弄个主题供自己用，后来发到Github和hexo官方，发现还是有不少朋友喜欢，在此一并感谢。最近Github反馈的问题很频繁，所以写个文档显得更为迫切和有必要\n\n### 主题概况\n\n大概介绍下，主题的统计用的`CNZZ`，评论组件用的`Disqus`，搜索是`Google InsightSearch`，大致风格是简书网的前身。对于统计和评论，你可以直接改主题的对应文件，替换就好了，只是考虑到统计为私有信息，因此把配置放到了站点配置文件中，如果你为此感到难受，请自己放到主题配置文件里就好。多余的不用纠结。\n\n> 主题发布这段时间，感谢热心网友提PR改进意见，现在主题已经支持**Gitment**，**代码高亮**也显示的比较顺眼了。由于个人原因，博文和主题前半年关注较少，再次一并感谢所有对开源做出贡献的朋友们，谢谢你们。后边，咱们一起装逼，一起飞....\n\n当你下载了这份主题，改好站点配置后，第一个工作不应该是`hexo g`或`hexo s`运行演示，因为这样你一定会遇到错误，要完整的运行，你需要手动配置如下项目：\n\n#### 1、写作模板文件配置\n\n在`scaffolds`文件夹下，保留两个文件即可：`post.md`和`page.md`，他们分别表示普通文章和独立页面\n\n**post**模板内容如下\n\n```\ntitle: {{ title }}\ndate: {{ date }}\nauthor: 托码斯\navatar: /images/favicon.png\nauthorLink: https://tangkunyin.com\nauthor: https://hello.tangkunyin.com\nauthorDesc: 一个写代码的「伪文人」categories: 科技\ntags:\n    - hexo\n    - web\nkeywords:\ndescription:\nphotos:\n- img/2017/demo.jpg\n---\n```\n\n> 如果新建的文章要归属于某个分类，请在`categories`处对应你的分类名称即可。标签使用同理，一篇文章可以有多个标签，打标签的方式就是写成数组方式。`photos`是缩略图，地址可以是相对的，也可以是绝对的。\n\n**page**模板同上，但没有`categories`和`tags`，多了`comments`，后者用来控制独立页是否支持评论组件。至于要把作者的信息放到模板里，是考虑到如果网站采用投稿方式，可以保留原创信息。即：显示不同作者不同文章信息，不会乱！\n\n#### 2、站点分类别名和自定义URL配置\n\n关于自定义URL，请参考这篇文章：[在hexo博客中打造相对完美的URL](https://blog.tangkunyin.com/tech/hexo-links-1483800845.html)\n\n**分类别名**和**标签别名**配置，站点`_config.yml`文件中，其中主题配置文件里的`menu`项需要和`category_map`键值对一致。二者顺序可以不同，但是主题中的顺序决定网站导航栏菜单的顺序。\n\n```\n# Category & Tag\ndefault_category: 技术\ncategory_map:\n   技术: tech\n   人文: humanity\ntag_map:\n  hexo: hexo\n  生活: life\n```\n\n\n#### 3、站点左侧导航配置\n\n```\n# 便于动态配置导航，最新版把左导航写成配置方式了。注意uri前边的\"-\"，这里是object类型，内层包了数组\nleftPagesMenu:\n- uri: pageName    // 这个是创建layout为page类型的页面名称，简而言之，就是独立页面名称\n  title: navName\t  // 故名意思，导航名称，这在大屏幕时体现\n  faName: fa-wifi  // FontAwesome样式名称，最新主题使用了4.7.0，请参考http://fontawesome.io/icons/\n```\n\n\n\n#### 4、社交信息\n\n最新一版支持了telegram, instagram, slack, twitter, github, sinaWb, facebook 7中，你要不嫌挤，可以全部配置上\n\n\n#### 5、关于搜索功能\n\n相对于静态博客而言，本站所使用的搜索功能，我个人觉得还是相当赞的，但是这并不意味着需要很复杂的配置，来一起看看你的`package.json`依赖吧：\n\n```\n\"dependencies\": {\n    \"hexo\": \"^3.2.2\",\n    \"hexo-git-backup\": \"^0.1.2\",\n    \"hexo-renderer-ejs\": \"^0.2.0\",\n    \"hexo-renderer-marked\": \"^0.2.11\",\n    \"hexo-renderer-stylus\": \"^0.3.1\",\n    \"hexo-server\": \"^0.2.0\",\n    \"hexo-deployer-git\": \"0.2.0\",\n    \"hexo-generator-archive\": \"^0.1.4\",\n    \"hexo-generator-category\": \"^0.1.3\",\n    \"hexo-generator-index\": \"^0.2.0\",\n    \"hexo-generator-tag\": \"^0.2.0\",\n    \"hexo-generator-json-content\": \"^2.2.0\"\n  }\n```\n\n请注意最后一行，那是用来生成检索数据`content.json`用的，这个文件在你的`public`下，当你无法使用搜索时，请务必检查依赖以及是否生成了数据文件。\n\n#### 6、关于CNAME多提一嘴\n\n有朋友提`Issues`说，`每次deploy之后，相应的CNAME文件就丢失了，难道每次deploy都需要重新创建CNAME文件，这个怎么解决啊？`\n\n这个只是你把`CNAME`文件放错位置了而已，解决办法就是**把CNAME文件放到主题的source文件夹中，这样就不会丢了**\n\n\n\n\n\n\n\n\n","tags":["hexo","web"],"categories":["科技"]},{"title":"macOS下超赞的工具推荐","url":"/tech/mac-tools.html","content":"\n\n![free-mac-usefull-tools](/img/2017/free-mac-usefull-tools.jpg)\n\n### 系统相关，一键直达\n\n[CleanMyMac](https://drive.google.com/file/d/1sCKdmRbx15ogzLa51s_kA5gBljqvJ5DF/view?usp=sharing)\n\n[ParallelsDesktop](https://drive.google.com/file/d/1kCwbIsv5NABPkiH1PPOByKBJ6i8odaKb/view?usp=sharing)\n\n[Charles](http://xclient.info/s/charles.html)\n\n\n### 其他资源，麻烦自提\n\n[ShareFreeAll](http://sharefreeall.com/counter-strike-1-6-keygen-serial-number-active-for-mac-os-x-offline-online/)\n\n[awesome-mac](https://github.com/jaywcjlove/awesome-mac)\n\n[XClient](https://xclient.info/s/)\n\n\n\n\n\n\n\n\n\n\n\n","tags":["麦克"],"categories":["科技"]},{"title":"在hexo博客中打造相对完美的URL","url":"/tech/hexo-links.html","content":"\n![hexo-blog-basic](/img/2017/hexo-blog-basic.jpg)\n\n## 这里讨论一个处女座的情怀问题\n\n如果你是全部用英文写作，那么这篇文章对你确实没什么Luan用。对hexo而言，我们可以很轻松的自定义文章URL。\n\n对数字敏感，你可以在站点的`_config.yml`文件中`permalink`处配置成`:year/:month/:day/:title/`。是的，这个不需要改动，保持hexo默认就是\n\n> 结果是：http://localhost:4000/2017/04/18/demo\n\n有静态网页情结的你，认为`.html`结尾利于`SEO`，则可以把`permalink`配置成`:category/:title.html`或`:category/:timestamp.html`\n\n> 结果是：http://localhost:4000/demo/1492523268.html\n\n注意第二种使用分类别名，请一定要设置两个地方：\n\n```\n// 1、站点的_config.yml中找到以下部分\n# Category & Tag\ndefault_category: uncategorized\ncategory_map:\n    演示: demo\ntag_map:\n\n// 2、scaffolds/post.md文件中改成如下\n---                                                                                                                               \ntitle: {{ title }}             \ndate: {{ date }}\ntags:                          \ntimestamp: {{ date }}          \ncategories: 演示\n---\n```\n\n是的，增加了两行，在写文章时，通过`hexo n demo`后，生成的`demo.md`文件里如下：\n\n```\n---                                                                                                                               \ntitle: hello\ncategories: 演示\ndate: 2017-04-18 22:19:45\ntimestamp: 1447295415\ntags:\n---\n```\n\n此时需要手动的把`timestamp`手动改成时间戳，因为这是你自定义的变量，当前`hexo`还没有这个系统变量使用，所以只能手动配置。\n\n通过以上方式体现的URL更有意义，但是用`title`或`timestamp`面临两个问题，前者遇到中文就呵呵了，后者虽精炼但无疑义。所以还有改进的空间，即使用`permalink: :category/:title.html`这样配置时，创建文章用英文标题。这样解决了中文一坨乱码且意义很明显，读者一看就知道这是哪个分类下的什么文章！\n\n是不是很美好，赶紧试试去吧~\n\n\n\n","tags":["hexo","web"],"categories":["科技"]},{"title":"About关于","url":"/about/index.html","content":"\n### 为何\n\n#### 写作\n\n> 读的书越多，你会发现知道的东西越多，不知道的东西就更多了，不知道远远大于知道，于是你在两者间不断碰撞、焦虑、欢喜、忧伤，产生各种思想、情感和故事，记录下来，就是文章。\n> > 引自《MacTalk》`跨越边界`\n\n#### 建站\n\n写作即思考，过程也好结论也罢，留存一份总是好的。最开始不太会折腾独立站点，于是就在平台化的博客做留存，后来发现维护和迁移成本比较高，于是就开始自己折腾。\n\n搭建这个网站主要是为了记录开发随笔，毕竟好记性不如烂键盘，当然装逼也是有的 😎️\n\n### 托码特人\n\n简言之，[托码特人](https://blog.tangkunyin.com)，聚焦于科技互联网领域，围绕软件研发、智能硬件、历史人文等话题，是一个关注科技与人文的技术博客。\n\n由于个人水平有限，文章中如若发现错误或不当言论，还望读者不吝赐教。\n\n本站的文章可任意转载，但请保留原文链接。如果某一篇帮助了你，请记得点个赞。\n\n### 其他的\n\n以后再说吧..."},{"title":"标签云","url":"/tags/index.html","content":"\n\n"},{"url":"/baidu_verify_codeva-zNsElYit6Z.html","content":"1b3a7cbf3d5275b22de0a0862d82f0aa"}]